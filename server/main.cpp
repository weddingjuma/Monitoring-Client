/******************************************************************
LUMServer is a program and user statistical gathering program built
for the University of Utah to collect user login statistics, and program
usage data for the Marriott Librarys Student Computing Labs.

The following libraries need to be installed on your system before you can
successfully compile this program:

-boost
-boost_thread
-pthread
-mysqlpp
-boost_system
-boost_regex

Copyright (C) 2013 Seth Walsh seth.walsh@utah.edu
******************************************************************/
/******************************************************************
This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
******************************************************************/
/******************************************************************
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
********************************************************************/

#include <iostream>
#include <stdlib.h>
#include <algorithm>
#include <fstream>

#include <boost/threadpool.hpp>
#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <boost/smart_ptr.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>

/* MySQL headers */
#include <mysql++/mysql++.h>

struct EVENT{
    std::string machine; // machine event came from
    unsigned long int timestamp; // timestamp for the event
    std::string user;   // user name
    int block_offset;   // block offset in the data structure
    unsigned int data; // unsigned integer representation of 32 bits for programs in use
    unsigned int guest_type; // unsigned integer representing guest account type 0 == user, 1 == gx, 2 == gp
};

static bool IS_RUNNING = false;
static int LISTEN_PORT = 16100;
static int SEND_PORT = 16200;
static char *DB = (char *)"LMServer3";
static char *DB_SERVER = (char *)"155.97.17.169";
static char *DB_USR = (char *)"lmon";
static char *DB_PSWD = (char *)"lm0nit0ring";
//static char *MASTERLIST = (char*)"masterlist.txt";
static int MSTATUS_TIMER = 30;

static FILE *efp;
static char *ERRLOG = (char*)"error.log";
boost::mutex mtx;

std::vector<std::string> MACHINE_LIST;
std::map<std::string, std::string> MAP_MNAME_IP;
std::map<std::string, int> MAP_MNAME_STATUS; // 3 == offline, 1 == logged in, 2 == logged out
std::map<std::string, int> BLACKLIST; // 1 == timeout, 2 == refused connection, 0 == communication working
std::vector<EVENT> EVENTS_TO_UPLOAD;
boost::mutex event_mutex;  // EVENTS vector is not guaranteed to be thread-safe
boost::mutex mlremove_mutex; // BLACK_LIST vector is not guaranteed to be thread-safe
std::set<std::string> BLACK_LIST; // Holds a list of unique machines that are blacklisted -- non responsive, calling home too often, etc
std::map<int, std::string> windows_list;
std::map<int, std::string> linux_list;

typedef boost::shared_ptr<boost::asio::ip::tcp::socket> socket_ptr;

int TEMPCOUNTER = 0; /// DEBUGGING !!!!

using namespace std;
using namespace boost::threadpool;

/** Because multiple EVENTs can be created from a given Client response this function has no return value, and
    will instead add each EVENT created onto the upload vector<>.  For a given char array from a Client, loop over
    the string, splitting into individual EVENTs.

    @param data     The EVENT data array
    @param machine  The machine name the EVENT came from
**/
void parse_event_block(char *data, string machine)
{
    if(data[1] == '0')
    {
        // No monitored programs currently running
        EVENT e;

        // Convert the 2 bytes containing HEX user name length to unsigned integer
        unsigned int uname_length;
        char tmp[2];
        tmp[0] = data[2];
        tmp[1] = data[3];
        stringstream ss;
        ss << hex << (tmp);
        ss >> uname_length;

        // Strip out the user name from the data array
        char user[uname_length];
        for(unsigned int i = 0; i < uname_length; i++)
        {
            user[i] = data[i + 4];
        }
        user[uname_length] = '\0'; // Terminate the user name so we don't get garbage

        // Strip out the timestamp and convert to unsigned long int
        char ts[10];
        for(int i = 0; i < 10; i++)
        {
            ts[i] = data[4 + uname_length + i];
        }
        unsigned long l = atol(ts);

        // Set EVENT member vars
        e.user = user;
        e.data = 0;
        e.machine = machine;
        e.timestamp = l;
        e.block_offset = 1;

        // Check timestamp, if its within last 60 seconds we can consider the machine logged in
        if((l > (unsigned long)(time(NULL) - 60)) && (data[0] == '2'))
        {
            MAP_MNAME_STATUS[machine] = 1;
        }

        // Regex expressions to search for particular user accounts in the EVENT and flag them accordingly in the database
        boost::regex gx("^gx", boost::regex::perl|boost::regex::icase);
        boost::regex gp("^gp", boost::regex::perl|boost::regex::icase);
        boost::match_results<std::string::const_iterator> results;

        // Set the account type by performing a regex on the user name
        if(boost::regex_search(e.user, results, gx))
        {
            e.guest_type = 1;
        }
        else if(boost::regex_search(e.user, results, gp))
        {
            e.guest_type = 2;
        }
        else
        {
            e.guest_type = 0;
        }

        // Lock the vector, no need to unlock as it is automatically taken care of when falling out of scope after this code block
        boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
        EVENTS_TO_UPLOAD.push_back(e);
    }
    else
    {
        EVENT e;
        int current_index = 0;
        int dlen = strlen(data);

        // Each pass of this loop will deal with a single EVENT stream that may contain multiple EVENT blocks
        while(current_index < dlen)
        {
            current_index++; // Increment by 1 at the start of a new EVENT

            // Get the number of blocks in this EVENT
            stringstream ss,ss1;
            ss << hex << data[current_index];
            unsigned int num_blocks;
            ss >> num_blocks;

            // Get length of user name
            unsigned int ulen;
            char usize[2];
            usize[0] = data[1 + current_index + (num_blocks * 8)]; // 16 + 1 + 1
            usize[1] = data[2 + current_index + (num_blocks * 8)];
            usize[2] = '\0';
            ss1 << hex << usize;
            ss1 >> ulen;

            // Get starting index of user name
            unsigned int ustart = 1 + current_index + 2 + (num_blocks * 8);
            char user[ulen];
            for(unsigned int x = 0; x < ulen; x++)
            {
                user[x] = data[ustart + x];
            }
            user[ulen] = '\0';

            // Get starting index of timestamp
            unsigned int tstart = 1 + current_index + 2 + (num_blocks *8) + ulen;
            char timestamp[10];
            for(unsigned int y = tstart; y < (tstart + 10); y++)
            {
                timestamp[y-tstart] = data[y];
            }
            timestamp[10] = '\0';
            unsigned long l = atol(timestamp);

            // Do all the splitting up
            current_index++;
            for(unsigned int i = 0; i < num_blocks; i++)
            {
                char block[8];
                for(int j = 0; j < 8; j++)
                {
                    block[j] = data[current_index];
                    current_index++;
                }
                block[8] = '\0';

                EVENT e;
                e.block_offset = i+1;
                stringstream ss2;
                ss2 << hex << block;
                ss2 >> e.data;
                e.machine = machine;
                e.user = user;
                e.timestamp = l;

                // Check timestamp, if its within last 60 seconds we can consider the machine logged in
                if((l > (unsigned long)(time(NULL) - 60)) && (data[0] == '2'))
                {
                    MAP_MNAME_STATUS[machine] = 1;
                }
                else
                {
                }

                // Regex expressions to search for particular user accounts in the EVENT and flag them accordingly in the database
                boost::regex gx("^gx", boost::regex::perl|boost::regex::icase);
                boost::regex gp("^gp", boost::regex::perl|boost::regex::icase);
                boost::match_results<std::string::const_iterator> results;

                // Set the account type by performing a regex on the user name
                if(boost::regex_search(e.user, results, gx))
                {
                    e.guest_type = 1;
                }
                else if(boost::regex_search(e.user, results, gp))
                {
                    e.guest_type = 2;
                }
                else
                {
                    e.guest_type = 0;
                }

                boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
                if(e.data == 0 && e.block_offset >= 2)
                {
                    /// No need to add the second EVENT data block into the DB if data == 0
                }
                else
                {
                    EVENTS_TO_UPLOAD.push_back(e);
                }
            }

            // Set current_index to next EVENT in stream
            current_index = tstart + 10;
        }
    }
}

/**
    Insert a given machine into the machines table in the database

    @param machine  The machine to insert
**/
bool db_machine_insert(string machine)
{
    mysqlpp::Connection conn(false);
    conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

    if(conn.connected())
    {
        try
        {
            mysqlpp::Query query = conn.query();
            query << "SELECT machine_id FROM machine WHERE machine_name=\"" << machine << "\"";
            mysqlpp::StoreQueryResult res = query.store();
            if(res.num_rows() == 0)
            {
                query << "INSERT INTO machine(machine_name,machine_a_id,machine_status,last_communication) VALUES(\"" << machine << "\",1," << MAP_MNAME_STATUS[machine] << ",unix_timestamp())";
                if(query.exec())
                {
                    conn.disconnect();
                    return true;
                }
            }
            else
            {
                conn.disconnect();
                return false;
            }
        }
        catch(mysqlpp::BadQuery e)
        {
            // Log any errors
            if(efp != NULL)
            {
                time_t now;
                struct tm *current;
                now = time(NULL);
                current = localtime(&now);
                char buffer[80];
                strftime(buffer, 80, "%c", current);
                std::string line = buffer;
                line = line + " -- DB Machine Insert Error: " + e.what();
                fputs(line.c_str(), efp);
            }
            conn.disconnect();
            return false;
        }
    }
    //std::cout << "Connection failure1 " << conn.error() << std::endl;
    return false;
}

/**
    Update the status for all machines being monitored
**/
bool update_all_machine_status()
{
    mysqlpp::Connection conn(false);
    conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

    if(conn.connected())
    {
        try
        {
            // Reset all machine status to offline
            mysqlpp::Query query = conn.query();
            query << "UPDATE machine SET machine_status=3";
            query.exec();
std::cout << "Setting all machine status's to offline" << std::endl;
            conn.disconnect();
            return true;
        }
        catch(mysqlpp::BadQuery e)
        {
            // Log any errors
            if(efp != NULL)
            {
                time_t now;
                struct tm *current;
                now = time(NULL);
                current = localtime(&now);
                char buffer[80];
                strftime(buffer, 80, "%c", current);
                std::string line = buffer;
                line = line + " -- Update Machine Status Error: " + e.what();
                fputs(line.c_str(), efp);
            }
            conn.disconnect();
            return false;
        }
    }
    else
    {
        //std::cout << "Connection failure3" << std::endl;
        return false;
    }
}

void handle_gather(string machine)
{
std::string tempIP;
    if(BLACKLIST[machine] > 0)
        return;
    try
    {
        boost::asio::io_service io_service;
        boost::asio::ip::tcp::resolver resolver(io_service);
        stringstream ss;
        ss << SEND_PORT;
        string buf = ss.str();
        std::map<std::string, std::string>::iterator it;
        it = MAP_MNAME_IP.find(machine);
tempIP = it->second;

        boost::asio::ip::tcp::resolver::query query(it->second, buf);
        boost::asio::ip::tcp::resolver::iterator itr = resolver.resolve(query);
        boost::asio::ip::tcp::socket socket(io_service);

        //boost::asio::socket_base::linger option(false); /* testing FD fix */
        //socket.native_handle().set_option(option);

        struct timeval tv;
        tv.tv_sec  = 30;
        tv.tv_usec = 0;
        setsockopt(socket.native(), SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        setsockopt(socket.native(), SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));

        boost::asio::connect(socket, itr);

        char message[2];
        message[0] = '2';
        message[1] = '\0';
        size_t rlen = strlen(message);
        boost::asio::write(socket, boost::asio::buffer(message, rlen));
        boost::asio::streambuf sbuf;
        size_t response_length = 1;
        char response[4096];
        std::string r_buffer;
        while(response_length > 0)
        {
            boost::system::error_code error;

            /*
                Rather than doing a read_some, we will read the entire stream into a buffer until the buffer is full.  Then loop as long as there is data on the stream.
                This prevents losing data from a machine that has not talked to the Server over an extended period of time, and prevents requiring the need to know the
                data length ahead of time.
            */
            //response_length = socket.read_some(boost::asio::buffer(response), error);
            response_length = boost::asio::read(socket, boost::asio::buffer(response), error);
            std::cout << "Read: " << response_length << " bytes from " << machine << std::endl;
            if(response_length > 0)
            {
                response[response_length] = '\0'; // This is needed to prevent garbage being included if the data is smaller than the buffer size
                r_buffer += response;
            }
        }

            if(r_buffer.length() > 0)//if(response_length > 0)
            {
//                response[response_length] = '\0'; // MAY NOT NEED!!!!
//r_buffer += response; /** TESTING NEW STRING METHOD OF DOING THIS SO EVENTS DONT GET TRUNCATED **/
                if(r_buffer.at(0) == '8')//if(response[0] == '8')
                {
                    // Machine is logged out == 2
                    std::map<std::string, int>::iterator it = MAP_MNAME_STATUS.find(machine);
                    if(it != MAP_MNAME_STATUS.end())
                    {
                        it->second = 2;
                    }
                    else
                    {
                        MAP_MNAME_STATUS.insert(std::pair<std::string, int>(machine, 2));
                    }
                }
                else
                {
                    if(r_buffer.at(0) == '2')//if(response[0] == '2')
                    {
                        // Machine is reachable (online), and logged in == 1
                        std::map<std::string, int>::iterator it = MAP_MNAME_STATUS.find(machine);
                        if(it != MAP_MNAME_STATUS.end())
                        {
                            it->second = 1;
                        }
                        else
                        {
                            MAP_MNAME_STATUS.insert(std::pair<std::string, int>(machine, 1));
                        }
                    }
                    else
                    {
                        // Badly formed data buffer
                    }
                }
            }
std::cout << "FULL STRING BUFFER FROM: " << machine << " -- " << r_buffer << std::endl;

            char *b = new char[r_buffer.size()+1];
            b[r_buffer.size()]=0;
            memcpy(b,r_buffer.c_str(), r_buffer.size());
            if(r_buffer.length() > 0)
            {
                if(r_buffer.at(0) == '2')//if(response[0] == '2')
                {
                    // Parse the data
                    parse_event_block(b, machine);
                }
            }
            delete b;

            if(socket.is_open())
            {
                socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);
                socket.shutdown(boost::asio::ip::tcp::socket::shutdown_receive);
                socket.close();
                //std::cout << "Closing socket: " << machine << std::endl;
            }

    }
    catch(boost::system::system_error &e)
    {
        std::cout << machine << " GatherError: " << e.what() << " WITH CODE: " << e.code() << std::endl;
        // Gather logging needs to go here
       /// errno 111 == connection refused
       /// errno 110 == connection timeout
        if(e.code() == boost::asio::error::timed_out)
        {
            BLACKLIST[machine] = 1;
            std::cout << machine << " CON TIMEOUT -- BLACKLISTING" << std::endl;
            MAP_MNAME_STATUS[machine] = 3;
            //update_mstatus(machine);
        }
        if(e.code() == boost::asio::error::connection_refused)
        {
            boost::unique_lock<boost::mutex> scoped_lock(mlremove_mutex);
            BLACKLIST[machine] = 1;
            std::cout << machine << " CON REFUSED -- BLACKLISTING" << std::endl;
            MAP_MNAME_STATUS[machine] = 3;
            //update_mstatus(machine);
        }
    }
}

void handle_listen(socket_ptr sock)
{
    // Handle all incoming communications from a Client here in a seperate thread
    try
    {
        for(;;)
        {
            char data[1024];

            boost::system::error_code error;
            size_t read_length = sock->read_some(boost::asio::buffer(data), error);
            if(error == boost::asio::error::eof)
                break; // Connection closed cleanly by Client
            else if(error)
                throw boost::system::system_error(error); // Some other error, maybe even SUCCESS

            int flag = data[0] - '0';
            data[read_length] = '\0';
            string mName = data;
            //mName = mName.substr(1);
            int os = data[1] - '0';
            mName = mName.substr(2);
//std::cout << mName << " called home with OS: " << os << " Flag: " << flag << std::endl;
            if(flag == 1)
            {
                // Client is calling home, add it to the list of machines to be monitored if not already on it
                if(std::find(MACHINE_LIST.begin(), MACHINE_LIST.end(), string(mName)) != MACHINE_LIST.end())
                {
                    // Client already exists on the list, so update its BLACKLIST status
                    if(BLACKLIST[mName] == 1)
                    {
                        BLACKLIST[mName] = 0;
                        std::cout << mName << " off BLACKLIST" << std::endl;
                    }
                    /*
                    else
                    {
                        BLACKLIST[mName] = 1;
                        std::cout << mName << " added BLACKLIST for possibly spamming" << std::endl;
                    }
                    */
                }
                else
                {
                    //boost::mutex mtx;
                    mtx.lock();
                    MACHINE_LIST.push_back(mName); /******** SEGFAULT HERE !!!!!!!!!!!!!!!!!!!!  ***********/
                    mtx.unlock();

                    MAP_MNAME_IP.insert(std::pair<std::string, std::string>(mName, sock->remote_endpoint().address().to_string()));

                    // Insert machine onto BLACKLIST, if it already exists set value to 0
                    BLACKLIST.insert(std::pair<std::string, int>(mName, 0));
                    //mtx.unlock();

                    if(!db_machine_insert(mName))
                    {
                        /// Log failure to insert new machine into the machine table
                    }
                }

                /// Send program list
                if(os == 1)
                {
                    std::string data = "";
                    for(int x = 0; x < windows_list.size(); ++x)
                    {
                        if(x > 0)
                            data = data + "," + windows_list[x];
                        else
                            data = data + windows_list[x];
                    }
                    size_t mlen = strlen(data.c_str());
                    //boost::asio::write(*sock, boost::asio::buffer(data, mlen));
                    size_t sent = sock->send(boost::asio::buffer(data, mlen));
//std::cout << "Windows sending: " << data << " " << sent << std::endl;
                }
                else if(os == 2)
                {
                    std::string data = "";
                    for(int x = 0; x < linux_list.size(); ++x)
                    {
                        if(x > 0)
                            data = data + "," + linux_list[x];
                        else
                            data = data + linux_list[x];
                    }
                    size_t mlen = strlen(data.c_str());
                    boost::asio::write(*sock, boost::asio::buffer(data, mlen));
//std::cout << "LInux sending: " << data << std::endl;
                }

            }
            sock->close();
            /** OTHER FLAGS need to go here --- TODO!!! **/

        }
        /*
        if(sock->is_open())
        {
            //sock->shutdown(boost::asio::ip::tcp::socket::shutdown_send);
            //sock->shutdown(boost::asio::ip::tcp::socket::shutdown_receive);
            //sock->close();
            //std::cout << "Closing LISTEN socket" << std::endl;
        }
        */
    }
    catch(std::exception &e)
    {
        // Listening logging needs to go here
        if(efp != NULL)
        {
            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            char buffer[80];
            strftime(buffer, 80, "%c", current);
            std::string line = buffer;
            line = line + " -- Listening Network Error: " + e.what();
            fputs(line.c_str(), efp);
        }
    }
}

void listen_task()
{
//pool p(100);
    while(true)
    {
        // Loop forever, listening for incoming communications from Clients, for each new connection
        //  spawn a thread to deal with that session
        boost::asio::io_service io_service;
        boost::asio::ip::tcp::acceptor a(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), LISTEN_PORT));
        a.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));

        for(;;)
        {
            socket_ptr sock(new boost::asio::ip::tcp::socket(io_service));
            a.accept(*sock);
            boost::thread t(boost::bind(handle_listen, sock)); /// May need to threadpool this to avoid too many open FD when all clients
                                                              /// try and connect at once...
        }
    }
}

void gather_task()
{
    while(true)
    {
        TEMPCOUNTER = 0;/// DEBUGGING
        // Wait until there are machines to be monitored
        if(MACHINE_LIST.size() == 0)
            sleep(1);
        else
        {
            // Reset all machine status to offline
            //update_all_machine_status(); /** Commenting this out for now, if a machine last reports logged in, but then the server is restarted, it has the chance to not get updated if it never talks again */

            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            while(current->tm_sec > 0)
            {
                sleep(1);
                now = time(NULL);
                current = localtime(&now);
            }

            // For each machine currently on the list, spawn a thread to connect and gather
std::cout << "MACHINE_LIST SIZE: " << MACHINE_LIST.size() << " :::: " << current->tm_min << ":" << current->tm_sec << std::endl;
            std::vector<boost::thread> thread_ids;
int COUNTER = 0;
            for(unsigned int i = 0; i < MACHINE_LIST.size(); i++)
            {
                if(BLACKLIST[MACHINE_LIST[i]] == 0)
                {
                    //p.schedule(boost::bind(handle_gather, MACHINE_LIST[i]));
                    //boost::mutex mtx2;
                    std::string machine = MACHINE_LIST[i];
                    //mtx2.lock();
                    //boost::thread t(boost::bind(handle_gather, MACHINE_LIST[i]));
                    boost::thread t(boost::bind(handle_gather, machine));
                    //thread_ids.push_back(t);
COUNTER++;
                }
                else
                    std::cout << "SKIPPING BLACKLIST STATUS for " << MACHINE_LIST[i] << ": " << BLACKLIST[MACHINE_LIST[i]] << std::endl;
            }
std::cout << "Sent gather request to: " << COUNTER << " machines out of " << MACHINE_LIST.size() << std::endl;

            now = time(NULL);
            current = localtime(&now);
            sleep(59 - current->tm_sec); // Sleep the rest of the current minute
        }
    }
}

void update_mstatus()
{
    /** Loop forever preventing this function from ever returning if a crash occurs **/
    try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);
        while(true)
        {
            if(conn.connected())
            {
                try
                {
                    std::map<std::string, int>::const_iterator it;
                    for(it = MAP_MNAME_STATUS.begin(); it != MAP_MNAME_STATUS.end(); ++it)
                    {
                        int machine_id;
                        mysqlpp::Query query = conn.query();
                        mysqlpp::StoreQueryResult res;

/* Temp blockingif(MAP_MNAME_STATUS[machine] == 0)
                    MAP_MNAME_STATUS[machine] = 2;
*/
                        if(it->second == 0)
                            MAP_MNAME_STATUS[it->first] = 2;

                        /** Lookup machine ID from database **/
                        //query << "SELECT machine_id FROM machine WHERE machine_name=\"" << machine << "\"";
                        query << "SELECT machine_id FROM machine WHERE machine_name=\"" << it->first << "\"";
                        if(res = query.store())
                        {
                            if(res.num_rows() == 0)
                            {
                                /** Machine does not exist in database yet, so add it **/
                                //query << "INSERT INTO machine(machine_name,machine_a_id,machine_status) VALUES(\"" << machine << "\",1," << MAP_MNAME_STATUS[machine] << ")";
                                query << "INSERT INTO machine(machine_name,machine_a_id,machine_status,last_communication) VALUES(\"" << it->first << "\",1," << it->second << ",unix_timestamp())";
                                query.exec();

                                //query << "SELECT machine_id FROM machine WHERE machine_name=\"" << machine << "\"";
                                query << "SELECT machine_id FROM machine WHERE machine_name=\"" << it->first << "\"";
                                if(res = query.store())
                                {
                                    for(size_t i = 0; i < res.num_rows(); ++i)
                                    {
                                        machine_id = res[i]["machine_id"];
                                    }

                                    /** Update the machine status **/
                                    //query << "UPDATE machine SET machine_status=" << machine << " WHERE machine_id=" << machine_id;
                                    query << "UPDATE machine SET machine_status=" << it->first << ",last_communication=unix_timestamp() WHERE machine_id=" << machine_id;
                                    query.exec();
                                }
                                else
                                {
                                    /// Query failed
                                }
                            }
                            else
                            {
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    machine_id = res[i]["machine_id"];
                                }

                                /** Update the machine status **/
                                //query << "UPDATE machine SET machine_status=" << MAP_MNAME_STATUS[machine] << " WHERE machine_id=" << machine_id;
                                if(it->second == 3)
                                {
                                    // If machine_status == OFFLINE, don't update the last_communication timestamp
                                    query << "UPDATE machine SET machine_status=" << it->second << " WHERE machine_id=" << machine_id;
                                }
                                else
                                {
                                    // Machine is reachable, so update both status and timestamp
                                    query << "UPDATE machine SET machine_status=" << it->second << ",last_communication=unix_timestamp() WHERE machine_id=" << machine_id;
                                }
                                //query << "UPDATE machine SET machine_status=" << it->second << ",last_communication=unix_timestamp() WHERE machine_id=" << machine_id;
                                query.exec();
                            }
                        }
                        else
                        {
                            /// Query failed -- select failed, means no machine in DB
                        }
                    }
                }
                catch(mysqlpp::BadQuery e)
                {
                    /** MySQL query error, log it **/
                }
            }
            else
            {
                /** DB connection has terminated, report to log file, attempt reconnect **/
                /// This does NOTHING currently, need to add the code to do something after you reconnect
            }
            sleep(MSTATUS_TIMER);
        }
    }
    catch(std::exception &e)
    {
        /** Some system error, log it **/
    }
}

void upload_task()
{
    /** Launch machine status updating thread **/
     try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

        while(true)
        {
            if(EVENTS_TO_UPLOAD.size() == 0)
                sleep(1);
            else
            {
                if(conn.connected())
                {
                  int user_id, machine_id;
/*
time_t now;
struct tm *current;
now = time(NULL);
current = localtime(&now);
std::cout << EVENTS_TO_UPLOAD.size() << " EVENTS to be added for " << current->tm_min << ":" << current->tm_sec << std::endl;
*/
                    // Obtain MUTEX
                    boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
                    EVENT e = EVENTS_TO_UPLOAD.back();
                    EVENTS_TO_UPLOAD.pop_back();

                    // Check to see if User already exists in the database
                    try
                    {
                        mysqlpp::Query query = conn.query();
                        query << "SELECT user_id FROM user WHERE user_name=\"" << e.user << "\"";

                        if(mysqlpp::StoreQueryResult res = query.store())
                        {
                            if(res.num_rows() > 0)
                            {
                                // 1 or more rows were returned so the user already exists in the DB
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    user_id = res[i]["user_id"];
                                }
                            }
                            else
                            {
                                // No user currently exists with that ID
                                std::cout << "Should be inserting new user... " << e.user << " -- " << res.num_rows() << std::endl;
                                if(e.user.length() > 8){std::cout << "Strange username from: " << e.machine << std::endl;}
                                // Insert the user into the DB
                                query << "INSERT INTO user(user_is_guest,user_name,guest_type) VALUES(1,\"" << e.user << "\"," << e.guest_type << ")";
                                if(!query.exec())
                                    std::cout << "Insert user failed!" << std::endl;

                                // Get the ID for the new user
                                query << "SELECT user_id FROM user WHERE user_name=\"" << e.user << "\"";

                                if(res = query.store())
                                {
                                    // 1 or more rows were returned
                                    for(size_t i = 0; i < res.num_rows(); ++i)
                                    {
                                        user_id = res[i]["user_id"];
                                    }
                                }
                                else
                                {
                                    /// Query failed -- inserting new user ID failed
                                }
                            }
                            query << "SELECT machine_id FROM machine WHERE machine_name=\"" << e.machine << "\"";
                            if(res = query.store())
                            {
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    machine_id = res[i]["machine_id"];
                                }

                                /// Insert EVENT
                                query << "INSERT INTO event(event_timestamp,event_machine_id,event_user_id,event_data,event_data_offset) ";
                                query << "VALUES(" << e.timestamp << "," << machine_id << "," << user_id << "," << e.data << "," << e.block_offset << ")";

                                if(!query.exec())
                                {
                                    //std::cout << query.str() << std::endl;
                                    //std::cout << "Insert event failed: " << query.error() << "   on: " << e.machine << std::endl;
                                }
                            }
                            else
                            {
                                /// Query failed -- no machine ID
                            }
                        }
                        else
                        {
                            /// Query failed -- no user ID
                        }
                    }
                    catch(mysqlpp::BadQuery e)
                    {
                        if(efp != NULL)
                        {
                            time_t now;
                            struct tm *current;
                            now = time(NULL);
                            current = localtime(&now);
                            char buffer[80];
                            strftime(buffer, 80, "%c", current);
                            std::string line = buffer;
                            line = line + " -- Upload Error: " + e.what();
                            fputs(line.c_str(), efp);
                        }
                        //std::cout << "update:: " << e.what() << std::endl;
                    }
                }
                else
                {
                    //conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);
                    std::cout << "CONNECTION FAILED!!!" << std::endl;
                }
            }
        }
    }
    catch(std::exception &e)
    {
        if(efp != NULL)
        {
            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            char buffer[80];
            strftime(buffer, 80, "%c", current);
            std::string line = buffer;
            line = line + " -- Upload Error: " + e.what();
            fputs(line.c_str(), efp);
        }
    }
}

/**
 Changing how I do this...
 - Connect to DB
 - Create a masterlist for each OS being monitored
 - Close connection
**/
void current_prog_setup()
{
    try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);
        mysqlpp::Query query = conn.query();
        int max_bit;

        // Get the MAX bit position currently in use
        query << "SELECT MAX(bit_pos) FROM programs";
        if(mysqlpp::StoreQueryResult res = query.store())
        {
            // Set the max bit position
            max_bit = res[0]["max(bit_pos)"];

            //std::map<int, std::string> windows_list;
            //std::map<int, std::string> linux_list;

            for(int j = 1; j <= max_bit; ++j)
            {
                windows_list.insert(std::pair<int,std::string>(j,std::string("")));
                linux_list.insert(std::pair<int,std::string>(j,std::string("")));
            }

            // Loop over current bits in use
            for(int i = 1; i <= max_bit; ++i)
            {
                // Strings to hold the process name for the program at the current bit position
                /**
                    In the future if other operating systems are added this will need to be modified to handle that
                **/
                std::string _wpname = "";
                std::string _lpname = "";
                int OS, primary;

                /// Indexed array of returned values
                ///     0 - pname
                ///     1 - OS
                ///     2 - primary pname (boolean)
                ///     3 - secondary pname
                query << "SELECT program_pname,program_OS,primary_pname,secondary_pname FROM programs WHERE bit_pos=" << i;

                if(res = query.store())
                {
                    // Iterate over every returned row
                    mysqlpp::StoreQueryResult::const_iterator it;
                    for(it = res.begin(); it != res.end(); ++it)
                    {
                        mysqlpp::Row row = *it;

                        OS = row[1];
                        primary = row[2];

                        if(OS==1)
                        {
                            if(primary==1)
                            {
                                _wpname = std::string(row[0]);
                                //windows_list.insert(std::pair<int,std::string>(i,_wpname));
                                windows_list[i] = _wpname;
                            }
                            else
                            {
                                // 2nd process name to look for
                                _wpname = std::string(row[3]);
                                _wpname = _wpname + std::string(":") + std::string(row[0]);
                                //windows_list.insert(std::pair<int,std::string>(i,_wpname));
                                windows_list[i] = _wpname;
                            }
                        }
                        else if(OS==2)
                        {
                            if(primary==1)
                            {
                                _lpname = std::string(row[0]);
                                //linux_list.insert(std::pair<int,std::string>(i,_lpname));
                                linux_list[i] = _lpname;
                            }
                            else
                            {
                                // 2nd process name to look for
                                _lpname = std::string(row[3]);
                                _lpname = _wpname + std::string(":") + std::string(row[0]);
                                //linux_list.insert(std::pair<int,std::string>(i,_lpname));
                                linux_list[i] = _lpname;
                            }
                        }
                    }
                }
            }

            for(int x = 1; x <= max_bit; ++x)
            {
                std::cout << "Windows Bit: " << x << " " << windows_list[x] << std::endl;
                std::cout << "Linux Bit: " << x << " " << linux_list[x] << std::endl;
            }
        }
        else
        {
            // Select max bit in use failed
            std::cout << "Select max_bit failed" << std::endl;
        }

        conn.disconnect();
    }
    catch(std::exception &e)
    {
        std::cout << "Current_prog_setup(): " << e.what() << std::endl;
    }
}

void init()
{
    cout << "Any Server initialization can be done here before startup" << endl;

    // Load files that are needed
    try{
        efp = fopen(ERRLOG, "w");
    }catch(exception &e)
    {
        std::cout << "INIT() -- " << e.what() << std::endl;
    }
}

/**
    Reads from the Server configuration file, setting all required parameters.  If any are missing, incorrectly set, or otherwise wrong,
    returns a -1 and forces the Server to shutdown.

    @return int value indicating success or failure
**/
int set_config_options()
{
    std::map<std::string, std::string> options;
    std::string line;
    std::ifstream cfgfile("config");
    if(!cfgfile)
    {
        std::cout << "No config file found" << std::endl;
        return -1;
    }
    while(cfgfile)//while(cfgfile >> id >> eq >> val)
    {
        getline(cfgfile, line);
        if(line[0] == '#' || line.compare("") == 0) continue; // skip comments
        //if(eq != "=") throw std::runtime_error("Parse error");
        else
        {
            std::cout << "line: " << line << std::endl;
            std::vector<std::string> s;
            boost::split(s, line, boost::is_any_of(" "));
            if(s.size() > 0)
            {
                options[s.at(0)] = s.at(2);
            }
        }
    }

    if(options["LISTEN_PORT"].compare("") == 0)
    {
        std::cout << "Configuration Error: No listen port configured in conf file" << std::endl;
        return -1;
    }
    else
        LISTEN_PORT = atoi(options["LISTEN_PORT"].c_str());
    if(options["SEND_PORT"].compare("") == 0)
    {
        std::cout << "Configuration Error: No send port configured in conf file" << std::endl;
        return -1;
    }
    else
        SEND_PORT = atoi(options["SEND_PORT"].c_str());
    if(options["DB"].compare("") == 0)
    {
        std::cout << "Configuration Error: No database configured in conf file" << std::endl;
        return -1;
    }
    else
        DB = &(options["DB"])[0];
    if(options["DB_SERVER"].compare("") == 0)
    {
        std::cout << "Configuration Error: No database server configured in conf file" << std::endl;
        return -1;
    }
    else
        DB_SERVER = &(options["DB_SERVER"])[0];
    if(options["DB_USER"].compare("") == 0)
    {
        std::cout << "Configuration Error: No user name configured in conf file" << std::endl;
        return -1;
    }
    else
        DB_USR = &(options["DB_USER"])[0];
    if(options["DB_PSWD"].compare("") == 0)
    {
        std::cout << "Configuration Error: No password configured in conf file" << std::endl;
        return -1;
    }
    else
        DB_PSWD = &(options["DB_PSWD"])[0];
    if(options["MSTATUS_TIMER"].compare("") == 0)
    {
        std::cout << "Configuration Error: No mstatus timer configured in conf file" << std::endl;
        return -1;
    }
    else
        MSTATUS_TIMER = atoi(options["MSTATUS_TIMER"].c_str());
    if(options["ERRLOG"].compare("") == 0)
    {
        std::cout << "Configuration Error: No error file configured in conf file" << std::endl;
        return -1;
    }
    else
        ERRLOG = &(options["ERRLOG"])[0];
    return 0;
}

void config()
{
    // Read config file and set variable parameters
    //if(set_config_options() < 0)
    //    exit(1);

    // Setup current programs
    current_prog_setup();
}

void run_server()
{
    time_t now;
    struct tm *current;
    now = time(NULL);
    current = localtime(&now);
    while(current->tm_sec > 0)
    {
        sleep(1);
        now = time(NULL);
        current = localtime(&now);
    }

    while(true)
    {
        if(!IS_RUNNING)
        {
            pool p(4); // 3 Tasks can be run in paralell, when run_server() returns, p is destroyed
            p.schedule(&gather_task);
            p.schedule(&listen_task);
            p.schedule(&upload_task);
            p.schedule(&update_mstatus);

            /** Schedule a task that will routinely check the database for changes to the program lists being monitored, if detected, then push the new lists to clients
            **/

            IS_RUNNING = true;
        }
        else
            sleep(1);
    }
}

int main()
{
    // Init
    init();

    // Config
    config();

    // Run -- needs 1 listener, 1 gather, 1 upload
    run_server();

    // Never gets to here
    return 0;
}
