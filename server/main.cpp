/******************************************************************
LUMServer is a program and user statistical gathering program built
for the University of Utah to collect user login statistics, and program
usage data for the Marriott Librarys Student Computing Labs.

The following libraries need to be installed on your system before you can
successfully compile this program:

-boost
-boost_thread
-pthread
-mysqlpp
-boost_system
-boost_regex

Copyright (C) 2013 Seth Walsh seth.walsh@utah.edu
******************************************************************/
/******************************************************************
This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
******************************************************************/
/******************************************************************
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
********************************************************************/

#include <iostream>
#include <stdlib.h>
#include <algorithm>
#include <fstream>
#include <sys/stat.h>

#include <boost/threadpool.hpp>
#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <boost/smart_ptr.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>

/* MySQL headers */
#include <mysql++/mysql++.h>

//#define DEBUG TRUE

struct EVENT{
    std::string machine; // machine event came from
    unsigned long int timestamp; // timestamp for the event
    std::string user;   // user name
    int block_offset;   // block offset in the data structure
    unsigned int data; // unsigned integer representation of 32 bits for programs in use
    unsigned int guest_type; // unsigned integer representing guest account type 0 == user, 1 == gx, 2 == gp
};

static bool IS_RUNNING = false;
static int LISTEN_PORT = 16100;
static int SEND_PORT = 16200;
static char *DB = (char *)"LMServer3";
static char *DB_SERVER = (char *)"";
static char *DB_USR = (char *)"";
static char *DB_PSWD = (char *)"";
//static char *MASTERLIST = (char*)"masterlist.txt";
static int MSTATUS_TIMER = 30;

static FILE *efp;
static char *ERRLOG = (char*)"error.log";
boost::mutex mtx;


std::vector<std::string> MACHINE_LIST;
std::map<std::string, std::string> MAP_MNAME_IP;
std::map<std::string, int> MAP_MNAME_STATUS; // 3 == offline, 1 == logged in, 2 == logged out
std::map<std::string, int> BLACKLIST; // 1 == timeout, 2 == refused connection, 0 == communication working
std::vector<EVENT> EVENTS_TO_UPLOAD;
boost::mutex event_mutex;  // EVENTS vector is not guaranteed to be thread-safe
boost::mutex mlremove_mutex; // BLACK_LIST vector is not guaranteed to be thread-safe
std::set<std::string> BLACK_LIST; // Holds a list of unique machines that are blacklisted -- non responsive, calling home too often, etc
std::map<int, std::string> windows_list;
std::map<int, std::string> linux_list;

typedef boost::shared_ptr<boost::asio::ip::tcp::socket> socket_ptr;
typedef boost::shared_ptr<boost::asio::ip::tcp::socket> socket_ptr2;

int TEMPCOUNTER = 0; /// DEBUGGING !!!!

using namespace std;
using namespace boost::threadpool;

/**
    Get the size of a File on disk
**/
int get_file_size(char *FILE)
{
   struct stat statbuf;
   if(stat(FILE, &statbuf) == -1)
   {
        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << "Error checking File size: " << errno << "\n";
        efile.close();
   }
   return (intmax_t)(statbuf.st_size);
}

/** Because multiple EVENTs can be created from a given Client response this function has no return value, and
    will instead add each EVENT created onto the upload vector<>.  For a given char array from a Client, loop over
    the string, splitting into individual EVENTs.

    @param data     The EVENT data array
    @param machine  The machine name the EVENT came from
**/
void parse_event_block(char *data, string machine)
{
    if(data[1] == '0')
    {
        // No monitored programs currently running
        EVENT e;

        // Convert the 2 bytes containing HEX user name length to unsigned integer
        unsigned int uname_length;
        char tmp[2];
        tmp[0] = data[2];
        tmp[1] = data[3];
        stringstream ss;
        ss << hex << (tmp);
        ss >> uname_length;

        // Strip out the user name from the data array
        char user[uname_length];
        for(unsigned int i = 0; i < uname_length; i++)
        {
            user[i] = data[i + 4];
        }
        user[uname_length] = '\0'; // Terminate the user name so we don't get garbage

        // Strip out the timestamp and convert to unsigned long int
        char ts[10];
        for(int i = 0; i < 10; i++)
        {
            ts[i] = data[4 + uname_length + i];
        }
        unsigned long l = atol(ts);

        // Set EVENT member vars
        e.user = user;
        e.data = 0;
        e.machine = machine;
        e.timestamp = l;
        e.block_offset = 1;

        // Check timestamp, if its within last 60 seconds we can consider the machine logged in
        if((l > (unsigned long)(time(NULL) - 60)) && (data[0] == '2'))
        {
            MAP_MNAME_STATUS[machine] = 1;
        }

        // Regex expressions to search for particular user accounts in the EVENT and flag them accordingly in the database
        boost::regex gx("^gx", boost::regex::perl|boost::regex::icase);
        boost::regex gp("^gp", boost::regex::perl|boost::regex::icase);
        boost::match_results<std::string::const_iterator> results;

        // Set the account type by performing a regex on the user name
        if(boost::regex_search(e.user, results, gx))
        {
            e.guest_type = 1;
        }
        else if(boost::regex_search(e.user, results, gp))
        {
            e.guest_type = 2;
        }
        else
        {
            e.guest_type = 0;
        }

        // Lock the vector, no need to unlock as it is automatically taken care of when falling out of scope after this code block
        boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
        EVENTS_TO_UPLOAD.push_back(e);
    }
    else
    {
        EVENT e;
        int current_index = 0;
        int dlen = strlen(data);

        // Each pass of this loop will deal with a single EVENT stream that may contain multiple EVENT blocks
        while(current_index < dlen)
        {
            current_index++; // Increment by 1 at the start of a new EVENT

            // Get the number of blocks in this EVENT
            stringstream ss,ss1;
            ss << hex << data[current_index];
            unsigned int num_blocks;
            ss >> num_blocks;

            // Get length of user name
            unsigned int ulen;
            char usize[2];
            usize[0] = data[1 + current_index + (num_blocks * 8)]; // 16 + 1 + 1
            usize[1] = data[2 + current_index + (num_blocks * 8)];
            usize[2] = '\0';
            ss1 << hex << usize;
            ss1 >> ulen;

            // Get starting index of user name
            unsigned int ustart = 1 + current_index + 2 + (num_blocks * 8);
            char user[ulen];
            for(unsigned int x = 0; x < ulen; x++)
            {
                user[x] = data[ustart + x];
            }
            user[ulen] = '\0';

            // Get starting index of timestamp
            unsigned int tstart = 1 + current_index + 2 + (num_blocks *8) + ulen;
            char timestamp[10];
            for(unsigned int y = tstart; y < (tstart + 10); y++)
            {
                timestamp[y-tstart] = data[y];
            }
            timestamp[10] = '\0';
            unsigned long l = atol(timestamp);

            // Do all the splitting up
            current_index++;

            /** DEBUGGING **/
            int _dbcount = 0;

            for(unsigned int i = 0; i < num_blocks; i++)
            {
                char block[8];
                for(int j = 0; j < 8; j++)
                {
                    block[j] = data[current_index];
                    current_index++;
                }
                block[8] = '\0';

                EVENT e;
                e.block_offset = i+1;
                stringstream ss2;
                ss2 << hex << block;
                ss2 >> e.data;
                e.machine = machine;
                e.user = user;
                e.timestamp = l;
/*** Debugging high BITS ***/
if(e.block_offset >= 2 && e.data >= 131072)
{
    std::cout << "HIGH BITS ON!!" << std::endl;
    std::cout << "machine: " << machine << std::endl;
    std::cout << "data: " << e.data << std::endl;
    std::cout << "time: " << e.timestamp << std::endl;
}
/*** ***/

                /** DEBUGGING trying to determine the cause of multiple offset=1 EVENTs from the same machine and timestamp**/
                if(e.block_offset == 1)
                {
                    _dbcount++;
                    if(_dbcount > 1)
                    {
                        std::cout << machine << ": ERROR with more than one offset, " << data << std::endl;
                    }
                }

                // Check timestamp, if its within last 60 seconds we can consider the machine logged in
                if((l > (unsigned long)(time(NULL) - 60)) && (data[0] == '2'))
                {
                    MAP_MNAME_STATUS[machine] = 1;
                }
                else
                {
                }

                // Regex expressions to search for particular user accounts in the EVENT and flag them accordingly in the database
                boost::regex gx("^gx", boost::regex::perl|boost::regex::icase);
                boost::regex gp("^gp", boost::regex::perl|boost::regex::icase);
                boost::match_results<std::string::const_iterator> results;

                // Set the account type by performing a regex on the user name
                if(boost::regex_search(e.user, results, gx))
                {
                    e.guest_type = 1;
                }
                else if(boost::regex_search(e.user, results, gp))
                {
                    e.guest_type = 2;
                }
                else
                {
                    e.guest_type = 0;
                }

                boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
                if(e.data == 0 && e.block_offset >= 2)
                {
                    /// No need to add the second EVENT data block into the DB if data == 0
                }
                else
                {
                    EVENTS_TO_UPLOAD.push_back(e);
                }
            }

            // Set current_index to next EVENT in stream
            current_index = tstart + 10;
        }
    }
}

/**
    Insert a given machine into the machines table in the database

    @param machine  The machine to insert
**/
bool db_machine_insert(string machine)
{
    mysqlpp::Connection conn(false);
    conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

    if(conn.connected())
    {
        try
        {
            mysqlpp::Query query = conn.query();
            query << "SELECT machine_id FROM machine WHERE machine_name=\"" << machine << "\"";
            mysqlpp::StoreQueryResult res = query.store();
            if(res.num_rows() == 0)
            {
                query << "INSERT INTO machine(machine_name,machine_a_id,machine_status,last_communication) VALUES(\"" << machine << "\",1," << MAP_MNAME_STATUS[machine] << ",unix_timestamp())";
                if(query.exec())
                {
                    conn.disconnect();
                    return true;
                }
            }
            else
            {
                conn.disconnect();
                return false;
            }
        }
        catch(mysqlpp::BadQuery e)
        {
            // Log any errors
            if(efp != NULL)
            {
                time_t now;
                struct tm *current;
                now = time(NULL);
                current = localtime(&now);
                char buffer[80];
                strftime(buffer, 80, "%c", current);
                std::string line = buffer;

                std::ofstream efile;
                efile.open(ERRLOG, std::ios_base::app);
                efile << line << " -- ERROR -- Database Machine Insert -- " << e.what() << "\n";
                efile.close();
            }
            conn.disconnect();
            return false;
        }
    }
    return false;
}

/**
    Update the status for all machines being monitored
**/
bool update_all_machine_status()
{
    mysqlpp::Connection conn(false);
    conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

    if(conn.connected())
    {
        try
        {
            // Reset all machine status to offline
            mysqlpp::Query query = conn.query();
            query << "UPDATE machine SET machine_status=3";
            query.exec();
            conn.disconnect();
            return true;
        }
        catch(mysqlpp::BadQuery e)
        {
            // Log any errors
            if(efp != NULL)
            {
                time_t now;
                struct tm *current;
                now = time(NULL);
                current = localtime(&now);
                char buffer[80];
                strftime(buffer, 80, "%c", current);
                std::string line = buffer;

                std::ofstream efile;
                efile.open(ERRLOG, std::ios_base::app);
                efile << line << " -- ERROR -- Update Machine Status -- " << e.what() << "\n";
                efile.close();
            }
            conn.disconnect();
            return false;
        }
    }
    else
    {
        return false;
    }
}
static int loop_counter = 0;
void handle_gather(string machine)
{
    if(BLACKLIST[machine] > 0) /*** INVALID READ of size 8 !!!  happens a lot!!! **/
    {
    /*
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- WARN -- Skipping Blacklisted Machine -- " << machine << "\n";
        efile.close();
    */
        return;
    }

    boost::asio::io_service io_service;
    boost::asio::ip::tcp::resolver resolver(io_service);
    stringstream ss;
    ss << SEND_PORT;
    string buf = ss.str();
    std::map<std::string, std::string>::iterator it;
    it = MAP_MNAME_IP.find(machine);
    std::string tempIP;
    tempIP = it->second;

    boost::asio::ip::tcp::resolver::query query(tempIP, buf);
    boost::asio::ip::tcp::resolver::iterator itr = resolver.resolve(query);
    boost::asio::ip::tcp::socket socket(io_service);

    socket.open(boost::asio::ip::tcp::v4());

    struct timeval tv;
    unsigned int timeout_milli = 10000;
    tv.tv_sec  = timeout_milli / 1000;
    tv.tv_usec = timeout_milli % 1000;
    setsockopt(socket.native(), SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
    setsockopt(socket.native(), SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));

    int optval = 0;
    int ret = setsockopt(socket.native(), SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));

    optval = 1;
    ret = setsockopt(socket.native(), SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

    struct linger lo = {1,0};
    setsockopt(socket.native(), SOL_SOCKET, SO_LINGER, &lo, sizeof(lo));

    try
    {
        boost::asio::connect(socket, itr);
        char message[2] = {0};
        message[0] = '2';
        message[1] = '\0';
        size_t rlen = strlen(message);
        boost::asio::write(socket, boost::asio::buffer(message, rlen)); /********** BLOCKING !!!! **********/

        boost::asio::streambuf sbuf;
        size_t response_length = 1;
        char response[4096] = {0};
        std::string r_buffer;
        while(response_length > 0)
        {
            boost::system::error_code error;

            /*
                Rather than doing a read_some, we will read the entire stream into a buffer until the buffer is full.  Then loop as long as there is data on the stream.
                This prevents losing data from a machine that has not talked to the Server over an extended period of time, and prevents requiring the need to know the
                data length ahead of time.
            */
            response_length = boost::asio::read(socket, boost::asio::buffer(response), error);

            if(response_length > 0)
            {
                response[response_length] = '\0'; // This is needed to prevent garbage being included if the data is smaller than the buffer size
                r_buffer += response;
            }
        }

        if(r_buffer.length() > 0)
        {
            if(r_buffer.at(0) == '8')
            {
                // Machine is logged out == 2
                std::map<std::string, int>::iterator it = MAP_MNAME_STATUS.find(machine);
                if(it != MAP_MNAME_STATUS.end())
                {
                    it->second = 2;
                }
                else
                {
                    MAP_MNAME_STATUS.insert(std::pair<std::string, int>(machine, 2));
                }
            }
            else
            {
                if(r_buffer.at(0) == '2')
                {
                    // Machine is reachable (online), and logged in == 1
                    std::map<std::string, int>::iterator it = MAP_MNAME_STATUS.find(machine);
                    if(it != MAP_MNAME_STATUS.end())
                    {
                        it->second = 1;
                    }
                    else
                    {
                        MAP_MNAME_STATUS.insert(std::pair<std::string, int>(machine, 1));
                    }
                }
                else
                {
                    // Badly formed data buffer
                }
            }
        }

        char *b = new char[r_buffer.size()+1](); /*** address is 0 bytes inside a block allocated for 2 bytes !!!***/
        memcpy(b,r_buffer.c_str(), r_buffer.size());
        if(r_buffer.length() > 0)
        {
            if(r_buffer.at(0) == '2')//if(response[0] == '2')
            {
                // Parse the data
                parse_event_block(b, machine);
            }
        }
        delete[] b;  /*** MISMATCHED FREE !!!**/
/** Testing a read check for EOF to let the client close the connection first **/
        //struct pollfd s_pfd = { socket.native(), POLLIN|POLLOUT, 0};
        //if(poll(&s_pfd, 1, -1) != 1) perror("poll");
        //if(s_pfd.revents|POLLIN){
        //    char c;
        //    int r;
        //    while((r = recv(socket.native(), &c, 1, MSG_DONTWAIT)) == 1){}
        //    if(r == 0){ }//std::cout << "FIN received for: " << machine << std::endl;}
        //    else if(errno == EAGAIN){ std::cout << "No more data for: " << machine << std::endl;}
        //    else{ perror("recv");}
        //}
/** End of testing EOF **/
        if(socket.is_open())
        {
            boost::system::error_code ec;
            socket.cancel(ec);
            if(ec)
            {
            }
            socket.close(ec);
            if(ec)
            {
            }
        }
    }
    catch(boost::system::system_error &e)
    {
        // Gather logging needs to go here
        /// errno 111 == connection refused
        /// errno 110 == connection timeout
        /// errno 113 == host unreachable
        if(e.code() == boost::asio::error::timed_out)
        {
            BLACKLIST[machine] = 1;
            MAP_MNAME_STATUS[machine] = 3;
        }
        else if(e.code() == boost::asio::error::connection_refused)
        {
            BLACKLIST[machine] = 1;
            MAP_MNAME_STATUS[machine] = 3;
        }
        else if(e.code() == boost::asio::error::host_unreachable)
        {
            BLACKLIST[machine] = 1;
            MAP_MNAME_STATUS[machine] = 3;
        }
        else
        {
            // All other errors
            std::cout << "Some other gathering error occurred: " << e.what() << std::endl;
        }
        socket.cancel();
        socket.close();

        if(socket.is_open())
        {
            std::cout << "Failed to close connection to: " << machine << " after receiving error: " << e.what() << std::endl;
        }
    }
}

void handle_listen(socket_ptr sock)
{
    // Handle all incoming communications from a Client here in a seperate thread
    try
    {
        char data[1024];
        boost::system::error_code error;
        size_t read_length = sock->read_some(boost::asio::buffer(data), error);
        if(error == boost::asio::error::eof)
            return; // Connection closed cleanly by Client
        else if(error)
            throw boost::system::system_error(error); // Some other error, maybe even SUCCESS

        int flag = data[0] - '0';
        data[read_length] = '\0';
        string mName = data;
        int os = data[1] - '0';
        mName = mName.substr(2);

        // Client is calling home, add it to the list of machines to be monitored if not already on it
        if(std::find(MACHINE_LIST.begin(), MACHINE_LIST.end(), string(mName)) != MACHINE_LIST.end())
        {
            // Client already exists on the list, so update its BLACKLIST status
            if(BLACKLIST[mName] == 1)
            {
                BLACKLIST[mName] = 0;
            }

            // Update the IPv4 Address associated with the client in case it has been changed recently
            MAP_MNAME_IP[mName] = sock->remote_endpoint().address().to_string();
        }

        if(flag == 1)
        {
            // Client is calling home, add it to the list of machines to be monitored if not already on it
            if(std::find(MACHINE_LIST.begin(), MACHINE_LIST.end(), string(mName)) != MACHINE_LIST.end())
            {
                // Client already exists on the list, so update its BLACKLIST status
                if(BLACKLIST[mName] == 1)
                {
                    BLACKLIST[mName] = 0;
                }

                // Update the IPv4 Address associated with the client in case it has been changed recently
                MAP_MNAME_IP[mName] = sock->remote_endpoint().address().to_string();
            }
            else
            {
                mtx.lock();
                if(!mName.empty())
                    MACHINE_LIST.push_back(mName); /******** SEGFAULT HERE !!!!!!!!!!!!!!!!!!!!  ***********/
                mtx.unlock();

                MAP_MNAME_IP.insert(std::pair<std::string, std::string>(mName, sock->remote_endpoint().address().to_string()));

                // Insert machine onto BLACKLIST, if it already exists set value to 0
                BLACKLIST.insert(std::pair<std::string, int>(mName, 0));

                if(!db_machine_insert(mName))
                {
                    /// Log failure to insert new machine into the machine table
                    time_t now;
                    struct tm *current;
                    now = time(NULL);
                    current = localtime(&now);
                    char buffer[80];
                    strftime(buffer, 80, "%c", current);
                    std::string line = buffer;

                    std::ofstream efile;
                    efile.open(ERRLOG, std::ios_base::app);
                    efile << line << " -- WARN -- Error Inserting new machine " << mName << " into database\n";
                    efile.close();
                }
            }

            /// Send program list
            if(os == 1)
            {
                std::string data = "";
                for(int x = 0; x < windows_list.size(); ++x)
                {
                    if(x > 0)
                        data = data + "," + windows_list[x];
                    else
                        data = data + windows_list[x];
                }
                size_t mlen = strlen(data.c_str());
                size_t sent = sock->send(boost::asio::buffer(data, mlen));
            }
            else if(os == 2)
            {
                std::string data = "";
                for(int x = 0; x < linux_list.size(); ++x)
                {
                    if(x > 0)
                        data = data + "," + linux_list[x];
                    else
                        data = data + linux_list[x];
                }
                size_t mlen = strlen(data.c_str());
/* debugging
                char data2[1024];
                boost::system::error_code error2;
                size_t read_length = sock->read_some(boost::asio::buffer(data2), error2);
                if(error2 == boost::asio::error::eof)
                {
                    std::cout << "OS=2 for " << mName << " failure to read to skipping write() with error: " << error2 << std::endl;
                    return; // Connection closed cleanly by Client
                }
                else if(error2)
                {
                    std::cout << "OS=2 for " << mName << " failure to read to skipping write() with error: " << error2 << std::endl;
                    throw boost::system::system_error(error2); // Some other error, maybe even SUCCESS
                }
*/
                boost::asio::write(*sock, boost::asio::buffer(data, mlen)); /*********** BLOCKING!! need to changed to avoid connections staying established **********/
            }
        }
        else
        {
        }

/** Testing a read check for EOF to let the client close the connection first **/
        //read_length = sock->read_some(boost::asio::buffer(data), error);
        //while(error != boost::asio::error::eof){
        //if(error == boost::asio::error::eof)
        //    return; // Connection closed cleanly by Client
        //else if(error)
        //std::cout << "Waiting 1 seconf for " << mName << " to close connection" << std::endl;
        //    sleep(1);//throw boost::system::system_error(error); // Some other error, maybe even SUCCESS
        //    read_length = sock->read_some(boost::asio::buffer(data), error);
        //}
        //std::cout << "Connection closed on client side for " << mName << std::endl;
/** End of testing EOF **/

        sock->cancel();
        sock->close();

        /** OTHER FLAGS need to go here --- TODO!!! **/
    }
    catch(std::exception &e)
    {
        // Listening logging needs to go here
        if(efp != NULL)
        {
            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            char buffer[80];
            strftime(buffer, 80, "%c", current);
            std::string line = buffer;

            std::ofstream efile;
            efile.open(ERRLOG, std::ios_base::app);
            efile << line << " -- ERROR -- Listening Network Error -- " << e.what() << "\n";
            efile.close();
        }
    }
}

void listen_task()
{
int call_home_count = 0;
    while(true)
    {
        // Loop forever, listening for incoming communications from Clients, for each new connection
        //  spawn a thread to deal with that session
        boost::asio::io_service io_service;
        boost::asio::ip::tcp::acceptor a(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), LISTEN_PORT));
        a.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
        boost::system::error_code error;
        boost::shared_ptr<boost::asio::ip::tcp::socket> sock = boost::make_shared<boost::asio::ip::tcp::socket>(boost::ref(io_service));

        try{
            a.accept(*sock);
            call_home_count++;

            boost::thread t(boost::bind(handle_listen, sock));
            t.join(); /// NEW stuff that can be removed??
            sock->close(error); /// NEW stuff that can be removed???

            if(sock.unique())
            {
                sock.reset();
            }

        }catch(std::exception& e){
            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            char buffer[80];
            strftime(buffer, 80, "%c", current);
            std::string line = buffer;

            std::ofstream efile;
            efile.open(ERRLOG, std::ios_base::app);
            efile << line << " -- ERROR -- Listen Task -- " << e.what() << "\n";
            efile.close();
        }
    }
}

void gather_task()
{
    while(true)
    {
        int fs = get_file_size(ERRLOG);
        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        //efile << "Error log size: " << fs << "\n";
        efile.close();

        // Wait until there are machines to be monitored
        if(MACHINE_LIST.size() == 0)
            sleep(1);
        else
        {
            // Reset all machine status to offline
            //update_all_machine_status(); /** Commenting this out for now, if a machine last reports logged in, but then the server is restarted, it has the chance to not get updated if it never talks again */

            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            while(current->tm_sec > 0)
            {
                sleep(1);
                now = time(NULL);
                current = localtime(&now);
            }

            for(unsigned int i = 0; i < MACHINE_LIST.size(); i++)
            {
                if(BLACKLIST[MACHINE_LIST[i]] == 0)
                {
                    std::string machine = MACHINE_LIST[i];
                    if(!machine.empty())
                    {
                        boost::thread t(boost::bind(handle_gather, machine));
                        //t.join();
                    }
                    else
                    {
                    }
                }
                else
                {
                    time_t now;
                    struct tm *current;
                    now = time(NULL);
                    current = localtime(&now);
                    char buffer[80];
                    strftime(buffer, 80, "%c", current);
                    std::string line = buffer;

                    std::ofstream efile;
                    efile.open(ERRLOG, std::ios_base::app);
                    efile << line << " -- WARN -- Skipping Blacklisted Machine -- " << MACHINE_LIST[i] << "\n";
                    efile.close();
                }
            }
            now = time(NULL);
            current = localtime(&now);
            sleep(59 - current->tm_sec); // Sleep the rest of the current minute
        }
    }
}

void update_mstatus()
{
    /** Loop forever preventing this function from ever returning if a crash occurs **/
    try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);
        while(true)
        {
            if(conn.connected())
            {
                try
                {
                    std::map<std::string, int>::const_iterator it;
                    for(it = MAP_MNAME_STATUS.begin(); it != MAP_MNAME_STATUS.end(); ++it)
                    {
                        int machine_id;
                        mysqlpp::Query query = conn.query();
                        mysqlpp::StoreQueryResult res;

                        if(it->second == 0)
                            MAP_MNAME_STATUS[it->first] = 2;

                        /** Lookup machine ID from database **/
                        query << "SELECT machine_id FROM machine WHERE machine_name=\"" << it->first << "\"";
                        if(res = query.store())
                        {
                            if(res.num_rows() == 0)
                            {
                                /** Machine does not exist in database yet, so add it **/
                                //query << "INSERT INTO machine(machine_name,machine_a_id,machine_status) VALUES(\"" << machine << "\",1," << MAP_MNAME_STATUS[machine] << ")";
                                query << "INSERT INTO machine(machine_name,machine_a_id,machine_status,last_communication) VALUES(\"" << it->first << "\",1," << it->second << ",unix_timestamp())";
                                query.exec();

                                //query << "SELECT machine_id FROM machine WHERE machine_name=\"" << machine << "\"";
                                query << "SELECT machine_id FROM machine WHERE machine_name=\"" << it->first << "\"";
                                if(res = query.store())
                                {
                                    for(size_t i = 0; i < res.num_rows(); ++i)
                                    {
                                        machine_id = res[i]["machine_id"];
                                    }

                                    /** Update the machine status **/
                                    //query << "UPDATE machine SET machine_status=" << machine << " WHERE machine_id=" << machine_id;
                                    query << "UPDATE machine SET machine_status=" << it->first << ",last_communication=unix_timestamp() WHERE machine_id=" << machine_id;

                                    query.exec();
                                }
                                else
                                {
                                    /// Query failed
                                }
                            }
                            else
                            {
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    machine_id = res[i]["machine_id"];
                                }

                                /** Update the machine status **/
                                //query << "UPDATE machine SET machine_status=" << MAP_MNAME_STATUS[machine] << " WHERE machine_id=" << machine_id;
                                if(it->second == 3)
                                {
                                    // If machine_status == OFFLINE, don't update the last_communication timestamp
                                    query << "UPDATE machine SET machine_status=" << it->second << " WHERE machine_id=" << machine_id;
                                }
                                else
                                {
                                    // Machine is reachable, so update both status and timestamp
                                    query << "UPDATE machine SET machine_status=" << it->second << ",last_communication=unix_timestamp() WHERE machine_id=" << machine_id;
                                    //std::cout << "QUERY1: " << query.str() << std::endl;
                                }
                                query.exec();
                            }
                        }
                        else
                        {
                            /// Query failed -- select failed, means no machine in DB
                        }
                    }
                }
                catch(mysqlpp::BadQuery e)
                {
                    /** MySQL query error, log it **/
                    time_t now;
                    struct tm *current;
                    now = time(NULL);
                    current = localtime(&now);
                    char buffer[80];
                    strftime(buffer, 80, "%c", current);
                    std::string line = buffer;

                    std::ofstream efile;
                    efile.open(ERRLOG, std::ios_base::app);
                    efile << line << " -- ERROR -- Bad MySQL Query -- " << e.what() << "\n";
                    efile.close();
                }
            }
            else
            {
                /** DB connection has terminated, report to log file, attempt reconnect **/
                /// This does NOTHING currently, need to add the code to do something after you reconnect
                 time_t now;
                struct tm *current;
                now = time(NULL);
                current = localtime(&now);
                char buffer[80];
                strftime(buffer, 80, "%c", current);
                std::string line = buffer;

                std::ofstream efile;
                efile.open(ERRLOG, std::ios_base::app);
                efile << line << " -- ERROR -- Update Machine Status DB Connection Failure-- \n";
                efile.close();

                // Attempt a reconnection to the database
                conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);
            }
            sleep(MSTATUS_TIMER);
        }
    }
    catch(std::exception &e)
    {
        /** Some system error, log it **/
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Update Machine Status -- " << e.what() << "\n";
        efile.close();
    }
}

void upload_task()
{
    /** Launch machine status updating thread **/
     try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

        while(true)
        {
            if(EVENTS_TO_UPLOAD.size() == 0)
                sleep(1);
            else
            {
                if(conn.connected())
                {
                  int user_id, machine_id;

                    // Obtain MUTEX
                    boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
                    EVENT e = EVENTS_TO_UPLOAD.back();
                    EVENTS_TO_UPLOAD.pop_back();

                    // Check to see if User already exists in the database
                    try
                    {
                        mysqlpp::Query query = conn.query();
                        query << "SELECT user_id FROM user WHERE user_name=\"" << e.user << "\"";

                        if(mysqlpp::StoreQueryResult res = query.store())
                        {
                            if(res.num_rows() > 0)
                            {
                                // 1 or more rows were returned so the user already exists in the DB
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    user_id = res[i]["user_id"];
                                }
                            }
                            else
                            {
                                // No user currently exists with that ID
                                // Insert the user into the DB
                                query << "INSERT INTO user(user_is_guest,user_name,guest_type) VALUES(1,\"" << e.user << "\"," << e.guest_type << ")";
                                if(!query.exec())
                                {
                                    time_t now;
                                    struct tm *current;
                                    now = time(NULL);
                                    current = localtime(&now);
                                    char buffer[80];
                                    strftime(buffer, 80, "%c", current);
                                    std::string line = buffer;

                                    std::ofstream efile;
                                    efile.open(ERRLOG, std::ios_base::app);
                                    efile << line << " -- WARN -- Insert user failed -- " << e.user << "\n";
                                    efile.close();
                                }

                                // Get the ID for the new user
                                query << "SELECT user_id FROM user WHERE user_name=\"" << e.user << "\"";

                                if(res = query.store())
                                {
                                    // 1 or more rows were returned
                                    for(size_t i = 0; i < res.num_rows(); ++i)
                                    {
                                        user_id = res[i]["user_id"];
                                    }
                                }
                                else
                                {
                                    /// Query failed -- inserting new user ID failed
                                }
                            }
                            query << "SELECT machine_id FROM machine WHERE machine_name=\"" << e.machine << "\"";
                            if(res = query.store())
                            {
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    machine_id = res[i]["machine_id"];
                                }

                                /// Insert EVENT
                                query << "INSERT INTO event(event_timestamp,event_machine_id,event_user_id,event_data,event_data_offset) ";
                                query << "VALUES(" << e.timestamp << "," << machine_id << "," << user_id << "," << e.data << "," << e.block_offset << ")";

                                if(!query.exec())
                                {
                                    //std::cout << query.str() << std::endl;
                                    //std::cout << "Insert event failed: " << query.error() << "   on: " << e.machine << std::endl;
                                }
                            }
                            else
                            {
                                /// Query failed -- no machine ID
                            }
                        }
                        else
                        {
                            /// Query failed -- no user ID
                        }
                    }
                    catch(mysqlpp::BadQuery e)
                    {
                        if(efp != NULL)
                        {
                            time_t now;
                            struct tm *current;
                            now = time(NULL);
                            current = localtime(&now);
                            char buffer[80];
                            strftime(buffer, 80, "%c", current);
                            std::string line = buffer;

                            std::ofstream efile;
                            efile.open(ERRLOG, std::ios_base::app);
                            efile << line << " -- ERROR -- Upload Task -- " << e.what() << "\n";
                            efile.close();
                        }
                    }
                }
                else
                {
                    //std::cout << "CONNECTION FAILED!!!" << std::endl;
                }
            }
        }
    }
    catch(std::exception &e)
    {
        if(efp != NULL)
        {
            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            char buffer[80];
            strftime(buffer, 80, "%c", current);
            std::string line = buffer;

            std::ofstream efile;
            efile.open(ERRLOG, std::ios_base::app);
            efile << line << " -- ERROR -- Upload Task -- " << e.what() << "\n";
            efile.close();
        }
    }
}

/**
 Changing how I do this...
 - Connect to DB
 - Create a masterlist for each OS being monitored
 - Close connection
**/
void current_prog_setup()
{
    try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);
        mysqlpp::Query query = conn.query();
        int max_bit;

        // Get the MAX bit position currently in use
        query << "SELECT MAX(bit_pos) FROM programs";
        if(mysqlpp::StoreQueryResult res = query.store())
        {
            // Set the max bit position
            max_bit = res[0]["max(bit_pos)"];

            for(int j = 1; j <= max_bit; ++j)
            {
                windows_list.insert(std::pair<int,std::string>(j,std::string("")));
                linux_list.insert(std::pair<int,std::string>(j,std::string("")));
            }

            // Loop over current bits in use
            for(int i = 1; i <= max_bit; ++i)
            {
                // Strings to hold the process name for the program at the current bit position
                /**
                    In the future if other operating systems are added this will need to be modified to handle that
                **/
                std::string _wpname = "";
                std::string _lpname = "";
                int OS, primary;

                /// Indexed array of returned values
                ///     0 - pname
                ///     1 - OS
                ///     2 - primary pname (boolean)
                ///     3 - secondary pname
                query << "SELECT program_pname,program_OS,primary_pname,secondary_pname FROM programs WHERE bit_pos=" << i;

                if(res = query.store())
                {
                    // Iterate over every returned row
                    mysqlpp::StoreQueryResult::const_iterator it;
                    for(it = res.begin(); it != res.end(); ++it)
                    {
                        mysqlpp::Row row = *it;

                        OS = row[1];
                        primary = row[2];

                        if(OS==1)
                        {
                            if(primary==1)
                            {
                                _wpname = std::string(row[0]);
                                //windows_list.insert(std::pair<int,std::string>(i,_wpname));
                                windows_list[i] = _wpname;
                            }
                            else
                            {
                                // 2nd process name to look for
                                _wpname = std::string(row[3]);
                                _wpname = _wpname + std::string(":") + std::string(row[0]);
                                //windows_list.insert(std::pair<int,std::string>(i,_wpname));
                                windows_list[i] = _wpname;
                            }
                        }
                        else if(OS==2)
                        {
                            if(primary==1)
                            {
                                _lpname = std::string(row[0]);
                                //linux_list.insert(std::pair<int,std::string>(i,_lpname));
                                linux_list[i] = _lpname;
                            }
                            else
                            {
                                // 2nd process name to look for
                                _lpname = std::string(row[3]);
                                _lpname = _wpname + std::string(":") + std::string(row[0]);
                                //linux_list.insert(std::pair<int,std::string>(i,_lpname));
                                linux_list[i] = _lpname;
                            }
                        }
                    }
                }
            }

            for(int x = 1; x <= max_bit; ++x)
            {
                //std::cout << "Windows Bit: " << x << " " << windows_list[x] << std::endl;
                //std::cout << "Linux Bit: " << x << " " << linux_list[x] << std::endl;
            }
        }
        else
        {
            // Select max bit in use failed
            //std::cout << "Select max_bit failed" << std::endl;
        }

        conn.disconnect();
    }
    catch(std::exception &e)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Current Program Setup -- " << e.what() << "\n";
        efile.close();
    }
}

void init()
{
    time_t now;
    struct tm *current;
    now = time(NULL);
    current = localtime(&now);
    char buffer[80];
    strftime(buffer, 80, "%c", current);
    std::string line = buffer;

    std::ofstream efile;
    efile.open(ERRLOG, std::ios_base::app);
    efile << line << " -- INFO -- LogMonitoring Server Initialization\n";
    efile.close();

    // Load files that are needed
    try{
        efp = fopen(ERRLOG, "w");
    }catch(exception &e)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Init error -- " << e.what() << "\n";
        efile.close();
    }
}

/**
    Reads from the Server configuration file, setting all required parameters.  If any are missing, incorrectly set, or otherwise wrong,
    returns a -1 and forces the Server to shutdown.

    @return int value indicating success or failure
**/
int set_config_options()
{
    std::map<std::string, std::string> options;
    std::string line;
    std::ifstream cfgfile("config");
    if(!cfgfile)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File.  System will now exit.\n";
        efile.close();
        return -1;
    }
    while(cfgfile)
    {
        getline(cfgfile, line);
        if(line[0] == '#' || line.compare("") == 0) continue; // skip comments
        else
        {
            std::cout << "line: " << line << std::endl;
            std::vector<std::string> s;
            boost::split(s, line, boost::is_any_of(" "));
            if(s.size() > 0)
            {
                options[s.at(0)] = s.at(2);
            }
        }
    }

    if(options["LISTEN_PORT"].compare("") == 0)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File [LISTEN_PORT].  System will now exit.\n";
        efile.close();
        return -1;
    }
    else
        LISTEN_PORT = atoi(options["LISTEN_PORT"].c_str());
    if(options["SEND_PORT"].compare("") == 0)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File [SEND_PORT].  System will now exit.\n";
        efile.close();
        return -1;
    }
    else
        SEND_PORT = atoi(options["SEND_PORT"].c_str());
    if(options["DB"].compare("") == 0)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File [DB].  System will now exit.\n";
        efile.close();
        return -1;
    }
    else
        DB = &(options["DB"])[0];
    if(options["DB_SERVER"].compare("") == 0)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File [DB_SERVER].  System will now exit.\n";
        efile.close();
        return -1;
    }
    else
        DB_SERVER = &(options["DB_SERVER"])[0];
    if(options["DB_USER"].compare("") == 0)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File [DB_USER].  System will now exit.\n";
        efile.close();
        return -1;
    }
    else
        DB_USR = &(options["DB_USER"])[0];
    if(options["DB_PSWD"].compare("") == 0)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File [DB_PSWD].  System will now exit.\n";
        efile.close();
        return -1;
    }
    else
        DB_PSWD = &(options["DB_PSWD"])[0];
    if(options["MSTATUS_TIMER"].compare("") == 0)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File [MSTATUS_TIMER].  System will now exit.\n";
        efile.close();
        return -1;
    }
    else
        MSTATUS_TIMER = atoi(options["MSTATUS_TIMER"].c_str());
    if(options["ERRLOG"].compare("") == 0)
    {
        time_t now;
        struct tm *current;
        now = time(NULL);
        current = localtime(&now);
        char buffer[80];
        strftime(buffer, 80, "%c", current);
        std::string line = buffer;

        std::ofstream efile;
        efile.open(ERRLOG, std::ios_base::app);
        efile << line << " -- ERROR -- Unable to read Configuration File [ERRLOG].  System will now exit.\n";
        efile.close();
        return -1;
    }
    else
        ERRLOG = &(options["ERRLOG"])[0];
    return 0;
}

void config()
{
    // Setup current programs
    current_prog_setup();
}

void run_server()
{
    time_t now;
    struct tm *current;
    now = time(NULL);
    current = localtime(&now);
    while(current->tm_sec > 0)
    {
        sleep(1);
        now = time(NULL);
        current = localtime(&now);
    }

    while(true)
    {
        if(!IS_RUNNING)
        {
            pool p(4); // 3 Tasks can be run in paralell, when run_server() returns, p is destroyed
            p.schedule(&gather_task);
            //boost::thread gt(gather_task);

            p.schedule(&listen_task);
            //boost::thread lt(listen_task);

            p.schedule(&upload_task);
            //boost::thread ult(upload_task);

            p.schedule(&update_mstatus);
            //boost::thread umt(update_mstatus);

            /** Schedule a task that will routinely check the database for changes to the program lists being monitored, if detected, then push the new lists to clients
            **/

            IS_RUNNING = true;

            //gt.join();
            //lt.join();
            //ult.join();
            //umt.join();
        }
        else
            sleep(1);
    }
}

int main()
{
    // Config
    config();

    // Init
    init();

    // Run -- needs 1 listener, 1 gather, 1 upload
    run_server();

    // Never gets to here
    return 0;
}
