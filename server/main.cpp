/******************************************************************
LUMServer is a program and user statistical gathering program built
for the University of Utah to collect user login statistics, and program
usage data for the Marriott Librarys Student Computing Labs.

The following libraries need to be installed on your system before you can
successfully compile this program:

-boost
-boost_thread
-pthread
-mysqlpp
-boost_system
-boost_regex
-boost_threadpool

Copyright (C) 2013 Seth Walsh seth.walsh@utah.edu
******************************************************************/
/******************************************************************
This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
******************************************************************/
/******************************************************************
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
********************************************************************/

#include <iostream>
#include <stdlib.h>
#include <algorithm>
#include <fstream>

/** Boost headers **/
#include <boost/threadpool.hpp>
#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <boost/smart_ptr.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>

/** MySQL headers **/
#include <mysql++/mysql++.h>

/**
    Struct representing a single EVENT block.  Each client machine can produce multiple EVENT blocks per minute but only a single EVENT per minute.  An EVENT contains the machine
    name that produced it, the epoch timestamp for that minute it was produced (on the clients time), the user name associated with that EVENT, the offset (which block it is), the data
    string in HEX of 32 bits where each bit is a program being monitored, and guest type if the user is a guest account.
**/
struct EVENT{
    std::string machine; // machine event came from
    unsigned long int timestamp; // timestamp for the event
    std::string user;   // user name
    int block_offset;   // block offset in the data structure
    unsigned int data; // unsigned integer representation of 32 bits for programs in use
    unsigned int guest_type; // unsigned integer representing guest account type 0 == user, 1 == gx, 2 == gp
};

/** Member variables **/
static bool IS_RUNNING = false; // Flag if Server is currently gathering
static int LISTEN_PORT = 16100; // Port to listen for Client communications comming in on
static int SEND_PORT = 16200; // Port to send communications to the Clients on
static char *DB = (char *)"LMServer3"; // Database name
static char *DB_SERVER = (char *)"155.97.17.169"; // Database Server IP
static char *DB_USR = (char *)"lmon"; // Database user
static char *DB_PSWD = (char *)"lm0nit0ring"; // Database pass
//static char *MASTERLIST = (char*)"masterlist.txt";
static int MSTATUS_TIMER = 30; //
static FILE *efp;
static char *ERRLOG = (char*)"error.log"; // Error log file
std::vector<std::string> MACHINE_LIST; // Machine name list
std::map<std::string, std::string> MAP_MNAME_IP; // Map machine dns names to IP addresses
std::map<std::string, int> MAP_MNAME_STATUS; // 3 == offline, 1 == logged in, 2 == logged out
std::map<std::string, int> BLACKLIST; // 1 == timeout, 2 == refused connection, 0 == communication working
std::vector<EVENT> EVENTS_TO_UPLOAD; // EVENTs collected in the last gather cycle to be uploaded to the DB
boost::mutex event_mutex;  // EVENTS vector is not guaranteed to be thread-safe
boost::mutex mlremove_mutex; // BLACK_LIST vector is not guaranteed to be thread-safe
std::set<std::string> BLACK_LIST; // Holds a list of unique machines that are blacklisted -- non responsive, calling home too often, etc
std::map<int, std::string> windows_list; // Map bit position to process name for Windows
std::map<int, std::string> linux_list; // Map bit position to process name for Linux
typedef boost::shared_ptr<boost::asio::ip::tcp::socket> socket_ptr;

/** Namespaces **/
using namespace std;
using namespace boost::threadpool;

/** Because multiple EVENTs can be created from a given Client response this function has no return value, and
    will instead add each EVENT created onto the upload vector<>.  For a given char array from a Client, loop over
    the string, splitting into individual EVENTs.

    @param data     The EVENT data array
    @param machine  The machine name the EVENT came from
**/
void parse_event_block(char *data, string machine)
{
    if(data[1] == '0')
    {
        // No monitored programs currently running
        EVENT e;

        // Convert the 2 bytes containing HEX user name length to unsigned integer
        unsigned int uname_length;
        char tmp[2];
        tmp[0] = data[2];
        tmp[1] = data[3];
        stringstream ss;
        ss << hex << (tmp);
        ss >> uname_length;

        // Strip out the user name from the data array
        char user[uname_length];
        for(unsigned int i = 0; i < uname_length; i++)
        {
            user[i] = data[i + 4];
        }
        user[uname_length] = '\0'; // Terminate the user name so we don't get garbage

        // Strip out the timestamp and convert to unsigned long int
        char ts[10];
        for(int i = 0; i < 10; i++)
        {
            ts[i] = data[4 + uname_length + i];
        }
        unsigned long l = atol(ts);

        // Set EVENT member vars
        e.user = user;
        e.data = 0;
        e.machine = machine;
        e.timestamp = l;
        e.block_offset = 1;

        // Check timestamp, if its within last 60 seconds we can consider the machine logged in
        if((l > (unsigned long)(time(NULL) - 60)) && (data[0] == '2'))
        {
            MAP_MNAME_STATUS[machine] = 1;
        }

        // Regex expressions to search for particular user accounts in the EVENT and flag them accordingly in the database
        boost::regex gx("^gx", boost::regex::perl|boost::regex::icase);
        boost::regex gp("^gp", boost::regex::perl|boost::regex::icase);
        boost::match_results<std::string::const_iterator> results;

        // Set the account type by performing a regex on the user name
        if(boost::regex_search(e.user, results, gx))
        {
            e.guest_type = 1;
        }
        else if(boost::regex_search(e.user, results, gp))
        {
            e.guest_type = 2;
        }
        else
        {
            e.guest_type = 0;
        }

        // Lock the vector, no need to unlock as it is automatically taken care of when falling out of scope after this code block
        boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
        EVENTS_TO_UPLOAD.push_back(e);
    }
    else
    {
        EVENT e;
        int current_index = 0;
        int dlen = strlen(data);

        // Each pass of this loop will deal with a single EVENT stream that may contain multiple EVENT blocks
        while(current_index < dlen)
        {
            current_index++; // Increment by 1 at the start of a new EVENT

            // Get the number of blocks in this EVENT
            stringstream ss,ss1;
            ss << hex << data[current_index];
            unsigned int num_blocks;
            ss >> num_blocks;

            // Get length of user name
            unsigned int ulen;
            char usize[2];
            usize[0] = data[1 + current_index + (num_blocks * 8)]; // 16 + 1 + 1
            usize[1] = data[2 + current_index + (num_blocks * 8)];
            usize[2] = '\0';
            ss1 << hex << usize;
            ss1 >> ulen;

            // Get starting index of user name
            unsigned int ustart = 1 + current_index + 2 + (num_blocks * 8);
            char user[ulen];
            for(unsigned int x = 0; x < ulen; x++)
            {
                user[x] = data[ustart + x];
            }
            user[ulen] = '\0';

            // Get starting index of timestamp
            unsigned int tstart = 1 + current_index + 2 + (num_blocks *8) + ulen;
            char timestamp[10];
            for(unsigned int y = tstart; y < (tstart + 10); y++)
            {
                timestamp[y-tstart] = data[y];
            }
            timestamp[10] = '\0';
            unsigned long l = atol(timestamp);

            // Do all the splitting up
            current_index++;
            for(unsigned int i = 0; i < num_blocks; i++)
            {
                char block[8];
                for(int j = 0; j < 8; j++)
                {
                    block[j] = data[current_index];
                    current_index++;
                }
                block[8] = '\0';

                EVENT e;
                e.block_offset = i+1;
                stringstream ss2;
                ss2 << hex << block;
                ss2 >> e.data;
                e.machine = machine;
                e.user = user;
                e.timestamp = l;

                // Check timestamp, if its within last 60 seconds we can consider the machine logged in
                if((l > (unsigned long)(time(NULL) - 60)) && (data[0] == '2'))
                {
                    MAP_MNAME_STATUS[machine] = 1;
                }
                else
                {
                }

                // Regex expressions to search for particular user accounts in the EVENT and flag them accordingly in the database
                boost::regex gx("^gx", boost::regex::perl|boost::regex::icase);
                boost::regex gp("^gp", boost::regex::perl|boost::regex::icase);
                boost::match_results<std::string::const_iterator> results;

                // Set the account type by performing a regex on the user name
                if(boost::regex_search(e.user, results, gx))
                {
                    e.guest_type = 1;
                }
                else if(boost::regex_search(e.user, results, gp))
                {
                    e.guest_type = 2;
                }
                else
                {
                    e.guest_type = 0;
                }

                boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
                if(e.data == 0 && e.block_offset >= 2)
                {
                    /// No need to add the second EVENT data block into the DB if data == 0
                }
                else
                {
                    EVENTS_TO_UPLOAD.push_back(e);
                }
            }

            // Set current_index to next EVENT in stream
            current_index = tstart + 10;
        }
    }
}

/**
    Insert a given machine into the machines table in the database

    @param machine  The machine to insert
    @ret   bool     True / False if machine insert was successful
**/
bool db_machine_insert(string machine)
{
    mysqlpp::Connection conn(false);
    conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

    if(conn.connected())
    {
        try
        {
            mysqlpp::Query query = conn.query();
            query << "SELECT machine_id FROM machine WHERE machine_name=\"" << machine << "\"";
            mysqlpp::StoreQueryResult res = query.store();
            if(res.num_rows() == 0)
            {
                query << "INSERT INTO machine(machine_name,machine_a_id,machine_status,last_communication) VALUES(\"" << machine << "\",7," << MAP_MNAME_STATUS[machine] << ",unix_timestamp())";
                if(query.exec())
                {
                    conn.disconnect();
                    return true;
                }
            }
            else
            {
                conn.disconnect();
                return false;
            }
        }
        catch(mysqlpp::BadQuery e)
        {
            // Log any errors
            if(efp != NULL)
            {
                time_t now;
                struct tm *current;
                now = time(NULL);
                current = localtime(&now);
                char buffer[80];
                strftime(buffer, 80, "%c", current);
                std::string line = buffer;
                line = line + " -- DB Machine Insert Error: " + e.what();
                fputs(line.c_str(), efp);
            }
            conn.disconnect();
            return false;
        }
    }
    return false;
}

/**
    Update the status for all machines being monitored.  All machines are initially set to offline at the start of each minute.

    @ret    bool    True / False if update of machines status was successful
**/
bool update_all_machine_status()
{
    mysqlpp::Connection conn(false);
    conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

    if(conn.connected())
    {
        try
        {
            // Reset all machine status to offline
            mysqlpp::Query query = conn.query();
            query << "UPDATE machine SET machine_status=3";
            query.exec();
            conn.disconnect();
            return true;
        }
        catch(mysqlpp::BadQuery e)
        {
            // Log any errors
            if(efp != NULL)
            {
                time_t now;
                struct tm *current;
                now = time(NULL);
                current = localtime(&now);
                char buffer[80];
                strftime(buffer, 80, "%c", current);
                std::string line = buffer;
                line = line + " -- Update Machine Status Error: " + e.what();
                fputs(line.c_str(), efp);
            }
            conn.disconnect();
            return false;
        }
    }
    else
    {
        return false;
    }
}


/**
    This threaded function serves as the main gathering point.  For each machine this function will attempt to contact that client by sending the appropriate flag message and collect
    any EVENTs the client has stored up.  Once collected they are sent to the EVENT parsing function which will deal with splitting the EVENT up into its various parts and parsing the
    data block.  This function also handles setting the client machines status (offline, logged out, logged in).  Because this function is threaded, handles only one client, and EVENT
    is timestamped it does not matter how long this function takes to return.

    @param string Machine name
**/
void handle_gather(string machine)
{
    // If the machine is on the blacklist for example spamming the call home function the Server will not attempt to contact it (IE: if some rogue program attempts to abuse the Servers listen port)
    if(BLACKLIST[machine] > 0)
        return;
    try
    {
        // Create a Boost socket and attempt to connect to the client
        boost::asio::io_service io_service;
        boost::asio::ip::tcp::resolver resolver(io_service);
        stringstream ss;
        ss << SEND_PORT;
        string buf = ss.str();
        std::map<std::string, std::string>::iterator it;
        it = MAP_MNAME_IP.find(machine);
        boost::asio::ip::tcp::resolver::query query(it->second, buf);
        boost::asio::ip::tcp::resolver::iterator itr = resolver.resolve(query);
        boost::asio::ip::tcp::socket socket(io_service);

        // Set the timeout to 30 seconds
        struct timeval tv;
        tv.tv_sec  = 30;
        tv.tv_usec = 0;
        setsockopt(socket.native(), SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        setsockopt(socket.native(), SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));

        // Connect the socket
        boost::asio::connect(socket, itr);

        char message[2];
        message[0] = '2';
        message[1] = '\0';
        size_t rlen = strlen(message);

        // Send the data request message
        boost::asio::write(socket, boost::asio::buffer(message, rlen));
        boost::asio::streambuf sbuf;
        size_t response_length = 1;
        char response[4096];
        std::string r_buffer;
        while(response_length > 0)
        {
            boost::system::error_code error;
            response_length = socket.read_some(boost::asio::buffer(response), error);

            if(response_length > 0)
            {
                response[response_length] = '\0'; // MAY NOT NEED!!!!
                r_buffer += response; /** TESTING NEW STRING METHOD OF DOING THIS SO EVENTS DONT GET TRUNCATED **/
                if(response[0] == '8')
                {
                    // Machine is logged out == 2
                    std::map<std::string, int>::iterator it = MAP_MNAME_STATUS.find(machine);
                    if(it != MAP_MNAME_STATUS.end())
                    {
                        it->second = 2;
                    }
                    else
                    {
                        MAP_MNAME_STATUS.insert(std::pair<std::string, int>(machine, 2));
                    }
                }
                else
                {
                    // Parse the EVENT data
                    if(response[0] == '2')
                    {
                        // Machine is reachable (online), and logged in == 1
                        std::map<std::string, int>::iterator it = MAP_MNAME_STATUS.find(machine);
                        if(it != MAP_MNAME_STATUS.end())
                        {
                            it->second = 1;
                        }
                        else
                        {
                            MAP_MNAME_STATUS.insert(std::pair<std::string, int>(machine, 1));
                        }
                    }
                }
            }
        }
        char *b = new char[r_buffer.size()+1];
        b[r_buffer.size()]=0;
        memcpy(b,r_buffer.c_str(), r_buffer.size());
        if(response[0] == '2')
        {
            // Parse the data that was received from the client which can be of N length
            parse_event_block(b, machine);
        }
        delete b;
    }
    catch(boost::system::system_error &e)
    {
        // Instead of logging to file any errors which could grow the log file too large, this is used to set the client machines status
       /// errno 111 == connection refused
       /// errno 110 == connection timeout
        if(e.code() == boost::asio::error::timed_out)
        {
            //BLACKLIST[machine] = 1;
            MAP_MNAME_STATUS[machine] = 3;
        }
        if(e.code() == boost::asio::error::connection_refused)
        {
            boost::unique_lock<boost::mutex> scoped_lock(mlremove_mutex);
            //BLACKLIST[machine] = 2;
            MAP_MNAME_STATUS[machine] = 3;
        }
    }
}

/**
    This threaded function deals with incomming communications from Clients.  Mainly used for clients calling home for the first time.  This will add new clients to the monitoring list,
    send the appropriate program list based on the OS of the client.

    @param socket_ptr socket of the Client
**/
void handle_listen(socket_ptr sock)
{
    // Handle all incoming communications from a Client here in a seperate thread
    try
    {
        for(;;)
        {
            char data[1024];

            boost::system::error_code error;
            size_t read_length = sock->read_some(boost::asio::buffer(data), error);
            if(error == boost::asio::error::eof)
                break; // Connection closed cleanly by Client
            else if(error)
                throw boost::system::system_error(error); // Some other error, maybe even SUCCESS

            int flag = data[0] - '0';
            data[read_length] = '\0';
            string mName = data;
            int os = data[1] - '0';
            mName = mName.substr(2);

            if(flag == 1)
            {
                // Client is calling home, add it to the list of machines to be monitored if not already on it
                if(std::find(MACHINE_LIST.begin(), MACHINE_LIST.end(), string(mName)) != MACHINE_LIST.end())
                {
                    // Client already exists on the list, so update its BLACKLIST status
                    if(BLACKLIST[mName] == 1)
                    {
                        BLACKLIST[mName] = 0;
                    }
                }
                else
                {
                    MACHINE_LIST.push_back(string(mName));
                    MAP_MNAME_IP.insert(std::pair<std::string, std::string>(mName, sock->remote_endpoint().address().to_string()));

                    // Insert machine onto BLACKLIST, if it already exists set value to 0
                    BLACKLIST.insert(std::pair<std::string, int>(mName, 0));

                    if(!db_machine_insert(mName))
                    {
                        /// Log failure to insert new machine into the machine table
                    }
                }

                /// Send program list
                if(os == 1)
                {
                    std::string data = "";
                    for(int x = 0; x < windows_list.size(); ++x)
                    {
                        if(x > 0)
                            data = data + "," + windows_list[x];
                        else
                            data = data + windows_list[x];
                    }
                    size_t mlen = strlen(data.c_str());
                    size_t sent = sock->send(boost::asio::buffer(data, mlen));

                }
                else if(os == 2)
                {
                    std::string data = "";
                    for(int x = 0; x < linux_list.size(); ++x)
                    {
                        if(x > 0)
                            data = data + "," + linux_list[x];
                        else
                            data = data + linux_list[x];
                    }
                    size_t mlen = strlen(data.c_str());
                    boost::asio::write(*sock, boost::asio::buffer(data, mlen));
                }
            }
            sock->close();
            /** OTHER FLAGS need to go here --- TODO!!! **/
        }
    }
    catch(std::exception &e)
    {
        // Listening logging needs to go here
        if(efp != NULL)
        {
            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            char buffer[80];
            strftime(buffer, 80, "%c", current);
            std::string line = buffer;
            line = line + " -- Listening Network Error: " + e.what();
            fputs(line.c_str(), efp);
        }
    }
}


/**
    This threaded function will loop forever.  For each new incomming connection attempt on the listen port it will spawn a new thread to deal with that connection.  This is a blocking
    function.
**/
void listen_task()
{
    while(true)
    {
        // Loop forever, listening for incoming communications from Clients, for each new connection
        //  spawn a thread to deal with that session
        boost::asio::io_service io_service;
        boost::asio::ip::tcp::acceptor a(io_service, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), LISTEN_PORT));
        a.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));

        for(;;)
        {
            socket_ptr sock(new boost::asio::ip::tcp::socket(io_service));
            a.accept(*sock);
            boost::thread t(boost::bind(handle_listen, sock)); /// May need to threadpool this to avoid too many open FD when all clients
                                                              /// try and connect at once...
        }
    }
}


/**
    This threaded function loops forever.  For each machine on the monitored list a new thread is spawned to deal with that machines data gathering.  This function cycles every minute.
**/
void gather_task()
{
    while(true)
    {
        // Wait until there are machines to be monitored
        if(MACHINE_LIST.size() == 0)
            sleep(1);
        else
        {
            // Reset all machine status to offline
            //update_all_machine_status(); /** Commenting this out for now, if a machine last reports logged in, but then the server is restarted, it has the chance to not get updated if it never talks again */

            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            while(current->tm_sec > 0)
            {
                sleep(1);
                now = time(NULL);
                current = localtime(&now);
            }

            // For each machine currently on the list, spawn a thread to connect and gather
            for(unsigned int i = 0; i < MACHINE_LIST.size(); i++)
            {
                if(BLACKLIST[MACHINE_LIST[i]] == 0)
                {
                    boost::thread t(boost::bind(handle_gather, MACHINE_LIST[i]));
                }
                else
                {
                    //std::cout << "SKIPPING BLACKLIST STATUS for " << MACHINE_LIST[i] << ": " << BLACKLIST[MACHINE_LIST[i]] << std::endl;
                }
            }

            now = time(NULL);
            current = localtime(&now);
            sleep(59 - current->tm_sec); // Sleep the rest of the current minute
        }
    }
}

/**
    This threaded function loops forever.  For each machine on the status list an update is made to the machines current status in the database.
**/
void update_mstatus()
{
    /** Loop forever preventing this function from ever returning if a crash occurs **/
    try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);
        while(true)
        {
            if(conn.connected())
            {
                try
                {
                    std::map<std::string, int>::const_iterator it;
                    for(it = MAP_MNAME_STATUS.begin(); it != MAP_MNAME_STATUS.end(); ++it)
                    {
                        int machine_id;
                        mysqlpp::Query query = conn.query();
                        mysqlpp::StoreQueryResult res;

                        if(it->second == 0)
                            MAP_MNAME_STATUS[it->first] = 2;

                        /** Lookup machine ID from database **/
                        query << "SELECT machine_id FROM machine WHERE machine_name=\"" << it->first << "\"";
                        if(res = query.store())
                        {
                            if(res.num_rows() == 0)
                            {
                                /** Machine does not exist in database yet, so add it **/
                                query << "INSERT INTO machine(machine_name,machine_a_id,machine_status,last_communication) VALUES(\"" << it->first << "\",1," << it->second << ",unix_timestamp())";
                                query.exec();

                                query << "SELECT machine_id FROM machine WHERE machine_name=\"" << it->first << "\"";
                                if(res = query.store())
                                {
                                    for(size_t i = 0; i < res.num_rows(); ++i)
                                    {
                                        machine_id = res[i]["machine_id"];
                                    }

                                    /** Update the machine status **/
                                    query << "UPDATE machine SET machine_status=" << it->first << ",last_communication=unix_timestamp() WHERE machine_id=" << machine_id;
                                    query.exec();
                                }
                                else
                                {
                                    /// Query failed
                                }
                            }
                            else
                            {
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    machine_id = res[i]["machine_id"];
                                }

                                /** Update the machine status **/
                                if(it->second == 3)
                                {
                                    // If machine_status == OFFLINE, don't update the last_communication timestamp
                                    query << "UPDATE machine SET machine_status=" << it->second << " WHERE machine_id=" << machine_id;
                                }
                                else
                                {
                                    // Machine is reachable, so update both status and timestamp
                                    query << "UPDATE machine SET machine_status=" << it->second << ",last_communication=unix_timestamp() WHERE machine_id=" << machine_id;
                                }
                                //query << "UPDATE machine SET machine_status=" << it->second << ",last_communication=unix_timestamp() WHERE machine_id=" << machine_id;
                                query.exec();
                            }
                        }
                        else
                        {
                            /// Query failed -- select failed, means no machine in DB
                        }
                    }
                }
                catch(mysqlpp::BadQuery e)
                {
                    /** MySQL query error, log it **/
                }
            }
            else
            {
                /** DB connection has terminated, report to log file, attempt reconnect **/
                /// This does NOTHING currently, need to add the code to do something after you reconnect
            }
            sleep(MSTATUS_TIMER);
        }
    }
    catch(std::exception &e)
    {
        /** Some system error, log it **/
    }
}

/**
    This threaded function is called at the end of the gathering cycle.  It uploads all EVENTs that were collected from the clients and then clears the EVENT list.  If new users or machines
    are found then they are added to the database in this function.
**/
void upload_task()
{
     try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);

        while(true)
        {
            if(EVENTS_TO_UPLOAD.size() == 0)
                sleep(1);
            else
            {
                if(conn.connected())
                {
                    int user_id, machine_id;

                    // Obtain MUTEX
                    boost::unique_lock<boost::mutex> scoped_lock(event_mutex);
                    EVENT e = EVENTS_TO_UPLOAD.back();
                    EVENTS_TO_UPLOAD.pop_back();

                    // Check to see if User already exists in the database
                    try
                    {
                        mysqlpp::Query query = conn.query();
                        query << "SELECT user_id FROM user WHERE user_name=\"" << e.user << "\"";

                        if(mysqlpp::StoreQueryResult res = query.store())
                        {
                            if(res.num_rows() > 0)
                            {
                                // 1 or more rows were returned so the user already exists in the DB
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    user_id = res[i]["user_id"];
                                }
                            }
                            else
                            {
                                // Insert the user into the DB
                                query << "INSERT INTO user(user_is_guest,user_name,guest_type) VALUES(1,\"" << e.user << "\"," << e.guest_type << ")";
                                if(!query.exec())
                                    std::cout << "Insert user failed!" << std::endl;

                                // Get the ID for the new user
                                query << "SELECT user_id FROM user WHERE user_name=\"" << e.user << "\"";

                                if(res = query.store())
                                {
                                    // 1 or more rows were returned
                                    for(size_t i = 0; i < res.num_rows(); ++i)
                                    {
                                        user_id = res[i]["user_id"];
                                    }
                                }
                                else
                                {
                                    /// Query failed -- inserting new user ID failed
                                }
                            }
                            query << "SELECT machine_id FROM machine WHERE machine_name=\"" << e.machine << "\"";
                            if(res = query.store())
                            {
                                for(size_t i = 0; i < res.num_rows(); ++i)
                                {
                                    machine_id = res[i]["machine_id"];
                                }

                                /// Insert EVENT
                                query << "INSERT INTO event(event_timestamp,event_machine_id,event_user_id,event_data,event_data_offset) ";
                                query << "VALUES(" << e.timestamp << "," << machine_id << "," << user_id << "," << e.data << "," << e.block_offset << ")";

                                if(!query.exec())
                                {
                                    // insert event failed
                                }
                            }
                            else
                            {
                                /// Query failed -- no machine ID
                            }
                        }
                        else
                        {
                            /// Query failed -- no user ID
                        }
                    }
                    catch(mysqlpp::BadQuery e)
                    {
                        if(efp != NULL)
                        {
                            time_t now;
                            struct tm *current;
                            now = time(NULL);
                            current = localtime(&now);
                            char buffer[80];
                            strftime(buffer, 80, "%c", current);
                            std::string line = buffer;
                            line = line + " -- Upload Error: " + e.what();
                            fputs(line.c_str(), efp);
                        }
                    }
                }
                else
                {
                    //connection failed
                }
            }
        }
    }
    catch(std::exception &e)
    {
        if(efp != NULL)
        {
            time_t now;
            struct tm *current;
            now = time(NULL);
            current = localtime(&now);
            char buffer[80];
            strftime(buffer, 80, "%c", current);
            std::string line = buffer;
            line = line + " -- Upload Error: " + e.what();
            fputs(line.c_str(), efp);
        }
    }
}

/**
 Changing how I do this...
 - Connect to DB
 - Create a masterlist for each OS being monitored
 - Close connection
**/
void current_prog_setup()
{
    try
    {
        mysqlpp::Connection conn(false);
        conn.connect(DB, DB_SERVER, DB_USR, DB_PSWD);
        mysqlpp::Query query = conn.query();
        int max_bit;

        // Get the MAX bit position currently in use
        query << "SELECT MAX(bit_pos) FROM programs";
        if(mysqlpp::StoreQueryResult res = query.store())
        {
            // Set the max bit position
            max_bit = res[0]["max(bit_pos)"];

            for(int j = 1; j <= max_bit; ++j)
            {
                windows_list.insert(std::pair<int,std::string>(j,std::string("")));
                linux_list.insert(std::pair<int,std::string>(j,std::string("")));
            }

            // Loop over current bits in use
            for(int i = 1; i <= max_bit; ++i)
            {
                // Strings to hold the process name for the program at the current bit position
                /**
                    In the future if other operating systems are added this will need to be modified to handle that
                **/
                std::string _wpname = "";
                std::string _lpname = "";
                int OS, primary;

                /// Indexed array of returned values
                ///     0 - pname
                ///     1 - OS
                ///     2 - primary pname (boolean)
                ///     3 - secondary pname
                query << "SELECT program_pname,program_OS,primary_pname,secondary_pname FROM programs WHERE bit_pos=" << i;

                if(res = query.store())
                {
                    // Iterate over every returned row
                    mysqlpp::StoreQueryResult::const_iterator it;
                    for(it = res.begin(); it != res.end(); ++it)
                    {
                        mysqlpp::Row row = *it;

                        OS = row[1];
                        primary = row[2];

                        if(OS==1)
                        {
                            if(primary==1)
                            {
                                _wpname = std::string(row[0]);
                                windows_list[i] = _wpname;
                            }
                            else
                            {
                                // 2nd process name to look for
                                _wpname = std::string(row[3]);
                                _wpname = _wpname + std::string(":") + std::string(row[0]);
                                windows_list[i] = _wpname;
                            }
                        }
                        else if(OS==2)
                        {
                            if(primary==1)
                            {
                                _lpname = std::string(row[0]);
                                linux_list[i] = _lpname;
                            }
                            else
                            {
                                // 2nd process name to look for
                                _lpname = std::string(row[3]);
                                _lpname = _wpname + std::string(":") + std::string(row[0]);
                                linux_list[i] = _lpname;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            // Select max bit in use failed
        }
        conn.disconnect();
    }
    catch(std::exception &e)
    {
        /** Logging TODO::: **/
    }
}

/**
    Initialization function.  Any Server initialization can be placed here.  For now it simply reads the config file and sets all the Server settings.
**/
void init()
{
    // Load files that are needed
    try{
        efp = fopen(ERRLOG, "w");
    }catch(exception &e)
    {
        /** Logging TODO::: **/
    }
}

/**
    Reads from the Server configuration file, setting all required parameters.  If any are missing, incorrectly set, or otherwise wrong,
    returns a -1 and forces the Server to shutdown.

    TODO::: logging of various config file errors needs to go here

    @return int value indicating success or failure
**/
int set_config_options()
{
    std::map<std::string, std::string> options;
    std::string line;
    std::ifstream cfgfile("config");
    if(!cfgfile)
    {
        // No config file found
        return -1;
    }
    while(cfgfile)//while(cfgfile >> id >> eq >> val)
    {
        getline(cfgfile, line);
        if(line[0] == '#' || line.compare("") == 0) continue; // skip comments
        else
        {
            std::vector<std::string> s;
            boost::split(s, line, boost::is_any_of(" "));
            if(s.size() > 0)
            {
                options[s.at(0)] = s.at(2);
            }
        }
    }

    if(options["LISTEN_PORT"].compare("") == 0)
    {
        //std::cout << "Configuration Error: No listen port configured in conf file" << std::endl;
        return -1;
    }
    else
        LISTEN_PORT = atoi(options["LISTEN_PORT"].c_str());
    if(options["SEND_PORT"].compare("") == 0)
    {
        //std::cout << "Configuration Error: No send port configured in conf file" << std::endl;
        return -1;
    }
    else
        SEND_PORT = atoi(options["SEND_PORT"].c_str());
    if(options["DB"].compare("") == 0)
    {
        //std::cout << "Configuration Error: No database configured in conf file" << std::endl;
        return -1;
    }
    else
        DB = &(options["DB"])[0];
    if(options["DB_SERVER"].compare("") == 0)
    {
        //std::cout << "Configuration Error: No database server configured in conf file" << std::endl;
        return -1;
    }
    else
        DB_SERVER = &(options["DB_SERVER"])[0];
    if(options["DB_USER"].compare("") == 0)
    {
        //std::cout << "Configuration Error: No user name configured in conf file" << std::endl;
        return -1;
    }
    else
        DB_USR = &(options["DB_USER"])[0];
    if(options["DB_PSWD"].compare("") == 0)
    {
        //std::cout << "Configuration Error: No password configured in conf file" << std::endl;
        return -1;
    }
    else
        DB_PSWD = &(options["DB_PSWD"])[0];
    if(options["MSTATUS_TIMER"].compare("") == 0)
    {
        //std::cout << "Configuration Error: No mstatus timer configured in conf file" << std::endl;
        return -1;
    }
    else
        MSTATUS_TIMER = atoi(options["MSTATUS_TIMER"].c_str());
    if(options["ERRLOG"].compare("") == 0)
    {
        //std::cout << "Configuration Error: No error file configured in conf file" << std::endl;
        return -1;
    }
    else
        ERRLOG = &(options["ERRLOG"])[0];
    return 0;
}

/**
    This function sets up the program list of monitored programs.
**/
void config()
{
    // Setup current programs
    current_prog_setup();
}

/**
    This function sets up the various threadpools and their assigned tasks (listening, gathering, uploading, status updating).
**/
void run_server()
{
    time_t now;
    struct tm *current;
    now = time(NULL);
    current = localtime(&now);
    while(current->tm_sec > 0)
    {
        sleep(1);
        now = time(NULL);
        current = localtime(&now);
    }

    while(true)
    {
        if(!IS_RUNNING)
        {
            pool p(4); // 3 Tasks can be run in paralell, when run_server() returns, p is destroyed
            p.schedule(&gather_task);
            p.schedule(&listen_task);
            p.schedule(&upload_task);
            p.schedule(&update_mstatus);

            /** Schedule a task that will routinely check the database for changes to the program lists being monitored, if detected, then push the new lists to clients
            **/

            IS_RUNNING = true;
        }
        else
            sleep(1);
    }
}

/**
    Main
**/
int main()
{
    // Init
    init();

    // Config
    config();

    // Run -- needs 1 listener, 1 gather, 1 upload
    run_server();

    // Never gets to here
    return 0;
}
